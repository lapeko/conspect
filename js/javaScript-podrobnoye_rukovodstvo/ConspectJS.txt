	мультивставка https://learn.javascript.ru/multi-insert

	- encodeURIComponent(line)															- заменяет пробелы и некоторые другие символы на %20 и т.д. подготавлявая строку для передачи по http
	- decodeURI­Com­po­nent(line)															- расшифровывает после encodeURIComponent()
Глава 2
	- некоторые встроенные функции:
	- ifFinite(variable)																	- проверка, является ли переменная числом. Может принимать строку
	- isNaN(variable)																		- антогонист предыдущей
	Интерпритация инструкции: если вторая строка не может быть интерпретированна как продолжение первой, то в конце первой строки ставится (;). Исключения: если первая строка break, continue или return то в конце строки ставится (;), если ++(--) - постфиксный, то он должен быть в одной строке с операндом, префиксный допустим в разных строчках.

Глава 3
	Типы данных можно разделить на две категории: простые, объектные.
	Простые: числа, строки, булевы, null, undefined
	Объекты: массив, объект window, функции, regExp, класс Error, Date, пользовательские классы
	Все типы имеют методы, кроме null и undefined. Переменные не имеют типа и могут принимать значения любых типов. В js используется лексическая область видимости.

Числа:
	от ±1,7976931348623157 × 10^308 до ±5 × 10^-324
	точность целых чисел –9007199254740992(–2^53 ) до 9007199254740992(2^53)
	в индексах массива используются 32х битные значения. 4 294 967 295 эле­мен­тов
	- to.fixed([number])																	- Метод Number. Переводит в string и форматирует число знаков после запятой, правиьно(математически) округляя. Без аргументов- 0 знаков после точки. Число- количество знаков после точки

Строки:
	- line.charAt(1)																		- Возращает строку, длинной 1 символ, содержщий символ под индексом 1 из строки line. line[1] - равнозначно
	- line.toLowerCase, (toUpperCase)												- Изменить регистр всех букв в нижний (верхний)
	- line.indexOf(subLine, /* optional */ index)								- Найти индекс начала подстроки в строке, -1 если совпадений нет. Если index задан, поиск начинается с индекса
	- line.lastIndexOf(subLine, /* optional */ index)							- Ищет с конца
	- substring(start [, end])															- Возвращает подстроку с позиции start до, но не включая end. Отрицательные индексы меняются на нули. если start > end, то аргументы меняются местами
	- substr(start [, length])															- Возвращает подстроку с позиции start, length символов
	- slice(start [, end])																- Тоже самое что и substring. Отрицательные индексы воспринимаются как отсчет от конца строки
	- String.fromCharCode(code)														- Возвращает символ по коду(Юникод) code
	- line.charCodeAt(0)																	- Переводит символ в код(Юникод)


объекты
	атрибуты св-в
		writable, enumerable, configurable, value
	атрибут объекта
		prototype, class. extensible

																								методы свойств:

	- Object.create(obj or null, [св-ва]);											- Создает объект, использует obj в качестве прототипа, вто­рой не­обя­за­тель­ный ар­гу­мент - свой­ст­ва но­во­го объ­ек­та
	- 'property' in object 																- проверяет наличие св-ва (даже если наследованио и даже если enumerable = false);
	- object.hasOwnProperty('property') 											- проверяет является ли своим свойством
	- object.propertyIsEnumerable('property') 									- проверяет является ли перечислимым && раьотает только с ownProperty
	- Object.keys(object) 																- возвращает имена собственных перечислимых свойств в виде массива
	- Object.getOwnPropertyNames(object) 											- возвращает все имена собственных свойств (и неперечислимые)
	- Object.getOwnPropertyDescriptor(object, 'property')						- возращает атрибуты свойства (только свои)
	- Object.defineProperty(object, 'property', { [descriptors] }) 		- устанавливает свойства и атрибуты
	- Object.defineProperties(object, {
		property1: {
			get: function(){ return ...; },
			writable: true...
		},
		property2: {...}...
	}); 																						- устанавливает атрибуты сразу нескольким свойствам объекта (пример с установкой гетера)
	- Object.getPrototypeOf(object) === proptotype								- вернет true, если прототипом object является prototype
	- prototype.isPrototypeOf(object)												- вернет true, если prototype является протипом или звеном в цепочке прототипов (похож на instanceof)

																								Методы расширяемости объектов
	- Object.preventExtensions(obj)													- Сделать объект нерасширяемым (Если новые свойства добавить в прототип, нерасширяемы объект унаследует св-ва)
	- Object.isExtensible(obj)															- Проверка на расширяемость объекта
	- Object.seal(obj)																	- Устанавливает isExtensible = false + configurable = false
	- Object.isSealed(obj)																- Проверяет применлся ли метод Object.seal()
	- Object.freeze(obj)																	- Тоже что и seal() + writable: false. Доступ через методы дступа остается.
	- Object.isFrozen()																	- Проверка применения метода freeze()
		preventExtensions(), seal(), freeze() - возращают обработанный объект
		
	JSON (JavaScript Object Notation)

		- JSON.stringify()																- сериализует только перечислимые св-ва переданного объекта
		- JSON.parse()
			Под­дер­жи­ва­ют­ся и  мо­гут быть се­риа­ли­зо­ва­ны и вос­ста­нов­ле­ны: объ­ек­ты, мас­си­вы, стро­ки, ко­неч­ные чи­сло­вые зна­че­ния, true, false и null. Зна­че­ния , Infinity и -Infinity се­риа­ли­зу­ют­ся в зна­че­ние null. Объ­ек­ты Date се­риа­ли­зу­ют­ся в  стро­ки с  да­та­ми в  фор­ма­те ISO (смот­ри­те опи­са­ние162 функ­ции Date.toJSON()), но JSON.parse() ос­тав­ля­ет их в  стро­ко­вом пред­став­ле­нии и  не вос­ста­нав­ли­ва­ет пер­во­на­чаль­ные объ­ек­ты Date. Объ­ек­ты Function, RegExp и  Error и  зна­че­ние undefined не мо­гут быть се­риа­ли­зо­ва­ны или вос­ста­нов­ле­ны. Функ­ция JSON.stringify() се­риа­ли­зу­ет толь­ко пе­ре­чис­ли­мые соб­ст­вен­ные свой­ст­	ва объ­ек­та. Ес­ли зна­че­ние свой­ст­ва не мо­жет быть се­риа­ли­зо­ва­но, это свой­ст­во про­сто ис­клю­ча­ет­ся из стро­ко­во­го пред­став­ле­ния.

Массивы
	
	- Array.isArray(arg)																	- Является массивом или нет (Нормально работает с EcmaScript5)
	- array.push(value)																	- Добавляет элемент в конец массива (аналог array[array.length] = value). arr.push([2, 3]); -> [x, y, [2, 3]]
	- array.pop(property)																- Удадяет и возвращает первый элемент в массиве
	- array.unshift(value)																- Добавляет элемент в начало массива (остальные элементы в массиве смещаются)
	- array.shift()																		- Удаляет из массива и возращает первый элемент. Остальные элементы сдвигаются.
	- array.join(line)																	- Объединяет все элементы массива в строку, если параметр функции отсутсвует, вставляются (', ') иначе line
	- array.reserve()																		- Реверс элементов массива
	- array.concat()																		- Новый массив = массив вызываюший метод + значений аргумента a.concat(4, [5,[6,7]]) -> [1,2,3,4,5,[6,7]]
	- array.slice(arg1, arg2)															- возращает фрагмент(массив), arg1, [arg2] - начало и конец фрагмента. Если arg < 0, то отсчет от конца массива (может обрабатывать массивоподобные элементы)
	- array.splice(arg1, arg2, args3...)											- вырезает чать и возвращает часть массива от array[arg1] до array[arg2]. args3 - список значений который вставится на вырезаное место. Если вставляется [1, 2], то в array так и вставится.
	- array.sort()																			- Сартирует массив в алфавитном порядке (временно преобразует в строки). Неопределенные элементы в конец. Так-же аргументом в sort можно вставить функцию фильтра. Пример function(a, b){ return a -b; }

																								Методы array в EcmaScript5:
	- forEach
		arr.forEach(function(value, index, array){ array[index] = value * value; });
																								- index и array - не обязательные атрибуты. Изменяет сам массив. Обрабатывает значения разряженного массива.
	- map
		arr.map(function(x){ return x * x });										- Возращает новый массив. Функция должна возращать значения. Обрабатывает разряженные значения.
	- filter
		var arr3 = arr.filter(function(value){ return value < 3; });		- Возращает новый массив со значениями, удовлетворяющие выражению функции. Пропускает значения разряженного массива (Возращает уплатненный массив)
	- every
		var bool = arr.every(function(x)){ x < 10 });							- Возращает true если все элементы удовлетворяют условию. Если есть false, конец цекла + возрат false. Иначе true.
	- some
		var bool = arr.some( function(x){ x < 10 });								- Возращает true если 1 элемент удовлетворяет условию. Если есть true, конец цикла + возврат true, иначе true.
	- reduce		var arr = [1, 2, 3, 4, 5];
		var newArr = arr.reduce(function(x, y){ x * y }, 1)					- (В этом случае возратит 120), результат итерации возращается в аргумент x, второй (необязательный) аргумент используется в качетве первого значения функции.
	- reduceRight																			- Тоже самое, но обработка начинается с конца
	- indexOf, lastIndexOf(arg1, arg2)												- Находит первый(последний) индекс искомого символа(arg1) в массиве, arg2(необязательный) - индекс начала поиска. 	(arg2) может быть отридцаетльным.

МассивоПодобные объекты
	Объекты у которых свойтва - числа в порядке возрастания от нуля ('0', '1', '2') и есть неотридцательное, целое до 32 байт свойство length. Применяются методы массивов из ecmaScript5, не измениющие сам массив, через вызов Array.prototype.map.call(obj, f(x));

Строки
	Ведут себя как массив для чтения. var line = 'line'; line[1] -> 'i'; Так-же применяются методы как и у МассивоПодобных элементов.

Функции(методы)
	Может определяться в инструкции объявления или в выражении определения функции. Имя(идентификатор) - обязателен для инструкции объявления и необязателен для выражания определения, если есть имя в выражении определения, то оно используется только в теле функции (ссылка на объект функции). Функ­ции, ко­то­рые реа­ли­зу­ют внут­рен­нюю скры­тую функ­цио­наль­ность, ино­гда на­чи­на­ют­ся с сим­во­ла под­чер­ки­ва­ния _.
	Выражения определений могут тут-же вызываться var square = (function(x){ return x * x; }(10));
	Инструкция объявления функции может применятся только в програмном коде верхнего уровня (везде кроме if/else, try/catch/finally, with)
	4 вида вызова функции: как функции, как методы, как конструкторы, косвенно (call(), apply()).
	Если метод ничего не возращает, полезно вернуть this(для создания цепочек вызовов). this метода - контекст вызова (ссылается на объект содержащиц метод)
	this - ключевое слово, привсаивание элементу this не допускается. this - не имеет области видимости и что-бы его передать в подфункцию, this - необходимо сохранить в переменную функции. То-же касается и arguments.
	При вызове конструктора без аргументов, допускается опустить скобки arr = new Array; Конструктор создает объект и контекстом вызова конструктора становится этот объект. Контсрукстор неявно возращает этот объект. В случае возращения пустого значения или примитивного типа, значение игнорируется и возращается новый объект.
	У массивоподобного объекта arguments есть свойство callee, который ссылается на выполняемую в данный момент функцию.
	При передаче более трех аргументов, лучше передать объект пример:
		function easycopy(args) {
			arraycopy(args.from,
			args.from_start || 0, // Об­ра­ти­те вни­ма­ние, как на­зна­ча­ют­ся
			args.to,              // зна­че­ния по умол­ча­нию
			args.to_start || 0,
			args.length);
		}
	Можно сде­лать свой код са­мо­до­ку­мен­ти­руе­мым, вы­би­рая опи­са­тель­ные име­на для па­ра­мет­рови, вклю­чая опи­са­ние ти­пов ар­гу­мен­тов в ком­мен­та­рии, как это сде­ла­но в при­ме­ре функ­ции arraycopy(). Для не­обя­за­тель­ных ар­гу­мен­тов коментить («optional»). Ес­ли функ­ция при­ни­мает про­из­воль­ное чис­ло ар­гу­мен­тов, ис­поль­зо­вать мно­го­то­чие:
		function max(/* чис­ло... */) { /* те­ло функ­ции */ }
	Так как функция является объектом (вызываемым), ее можно сохранять в другие переменные. Так-же можно передавать объекты функций в другие функции для формирования 'состовной' фунции.
	В нестрогом режиме массив argements изменяет свои значения при изменении аргументов, в строгом- нет -> func(a, b){a = 3; console.log(arguments[0] == a;)} //false; func(1,2);
	
																								Свойства и методы функций

	- length 																				- примененная к функции возращает количество ожидаемых аргументов (объявленных параметров). Доступно только для чтения.
	- call(), aplly()																		- контекст вызова функции. func.call(obj); применит функцию call как метод объекта obj. call - принимает аргументы через запятую, apply - после объекта - массив. Apply может работать и с массивоподобными объектами.
	- method.bind(obj, args)															- вызывает функцию method как метод объекта oblect, в отличие от aplly - связывает аргументы (частичное применение).
	- Function																				- function summ(x, y){ return x + y; }; var summ2 = summ.bind(null, 2); summ2(3); => 5
	-	var f = new Function(par1, par2, body);									- конструктор создает анонимные функции, все параметры (кроме последнего), параметры для аргументов. Последний переметр принимает строку с телом функции. Особенности: 1 - позволяет динамически создавать функции. 2 - При каждом вызове производится синтаксический анализ (в цикле лучше не создавать так функции). 3 - функции созданные этим конструктором напоминают функцию eval() вызванную из глобального контекста.
	- Функ­ции выс­ше­го по­ряд­ка															- это функ­ции, ко­то­рые опе­ри­ру­ют функ­ция­ми, при­ни­мая од­ну или бо­лее функ­ций и воз­вра­щая но­вую функ­цию.
	- Мемоизация																			- сохранение данных в замыкании (можно использовать для кэширования данных - при вызове функции проверять вызывалась ли функция с такими оргументами и возращать знаение из кэша)

Классы и конструкторы
	- Класс в js																			- это множество объектов имеющих общий прототип.
	- Способы определения классов														- 1) Фабричная функция 2) Через конструктор
	При вызове new создается новый объект, а конструктор лишь инициализирует новый объект.
	- obj instanceof(Class) 															- проверяет является ли объект классом или подклассом Class. В действительности instanceof проверяет содержит ли объект в цепочке прототипов Class.prototype
	- Class.prototype.isPrototypeOf(obj)											- аналог instanceof, проверяет находится ли Class.prototype в цепочке прототипов объекта obj
	При переопределении Construtor.prototype, заменяется свойство constructor у конструктора. Для решения, нужно задать свойство constructor явно. Либо не переопределять, а расширять прототип конструктора.
	Наследование от прототипов происходит динамически -> при добавлении методов прототипу, методы наследуются уже созданными объектами. Можно расширять основные типы js.
	Грубое определение типов - проверка наличия у иследуемого объекта необходимых свойств

	методы классов:
	toString, toLocalString, valueOf, toJSON

	Определение подклассов
	B.prototype = Object.create(A.prototype);
	B.prototype.constructor = B;
	При изменении методов суперкласса, динамически изменяются методы подкласса. Если в суперкласс добавить метод, он автоматом добавляется в подкласс (если нет метода с таким-же именем)
	При создании фобричных функций, имя конструктора суперкласса лучше сохранять в переменную (superclass), это даст преимущество при изменении имени суперкласса
	Свойства только для чтения, наследуются и у наследников не возможно определить данное свойтво. Для переопределения использовать defineProperty(ies), Object.create
	Для без­оши­боч­ной ра­бо­ты мо­ду­ли долж­ны стре­мить­ся из­бе­гать вне­се­ния из­ме­не­ний в гло­баль­ную сре­ду вы­пол­не­ния

Регулярные выражения
	+ * ?																						- жадные повторения
	+? *? ??																					- нежадное повторение. При применении /a+?b/ к 'aab'- захватит всю последовательность, т.к. захватывает от начала
	[]																							- классы символов
	()																							- нумеруемая группировка, имеет 2 цели. 1 - для применения +*?| - ([ab]|[bs]), (abc)*. 2 - для выделения группы и получения ссылки на нее
	(?: )																						- ненумеруемая группировка (не предоставляет ссылку)
	\1																							- ссылка на первую груупу, недопустимо применять внутри класса. /(['"])[^'"]*\1/ - выберет строку начинающуюся с одинарной или двойной кавычки, любого числа символов (не кавычек) и закрывающуюся кавычку (такую-жу как и открывающую). Нумерация отсчитывается слева на право по открывающей скобке '('.
	(?= ) или (?! )																		- опережающая проверка, выражения в этих груупах не попадает в результат. /[jJ]ava(?!Script)[A-Z][a-z]+(?=\:)/ - Проверит чтобы слово начиналось с Java, за ним не было-бы слова Script, но шло слово и полсе него было двоеточие.
	\b																							- якорный символ соответствующий границе слова, \B - якорный символ (не граница слова -> входит в это слово)
	[\b]																						- символ забоя (backspace вроде) !!!
	Флаги: фла­ги ука­зы­ва­ют­ся по­сле вто­ро­го слэ­ша. i - не учитывать регистр, g - Вы­пол­ня­ет гло­баль­ный по­иск, т. е. на­хо­дит все со­от­вет­ст­вия, а не ос­та­нав­ли­ва­ет­ся по­сле пер­во­го из них, m - Мно­го­строч­ный ре­жим. ^ со­от­вет­ст­ву­ет на­ча­лу стро­ки или на­ча­лу все­го стро­ко­во­го вы­ра­же­ния, а $ – кон­цу стро­ки или все­го вы­ра­же­ния.

																								Метода string для работы с RegExp

	- search(regExp)																		- возращает позицию первого совпадения или -1. Не поддерживает флаг g. Если аргуметом переданна строка, она передаетсяя конструктору RexExp и влзращается рег. выр.
	- replace(regExp, lineForReplace)												- заменяет совпадение регулярного выражения вторым аргументом, если есть флаг g, заменяются все совпадения, иначе только первое. Если первый аргумент строка, производится посимвольный поиск на совпадение (не создается регулярное выражение). Вторым аргументом допустимо использовать ссылки из результата на шруппы рег. выр. Пример line = '\'Привет\''.replace(/'([А-Яа-я]+)'/, '"$1"') -> line = "Привет"
	- match(regExp)																		- Возращает массив совпадения(й) с регулрным выражением в зависимости от флага. Если первый аргумент строка, то он преобразуется с помощью RegExp(). Если флаг g, то возращается массив всех совпадений. Если флага g нет, тогда первый элемент массива, это искомое выражение, а отсальные элементы массива - подвыражения регулярного выражения.
	- split()																				- Принимает аргументом разделитель, и возращает массив. Работает как со стоковыми литералами, так и с регулярными выражениями.

																								Методы RegExp

	Помимо конструктора имеет три метода и пять свойств, source - строка регуляррого выражения. булевы и только для чтения - global, ignoreCase, multiline, lastIndex – это це­лое чис­ло, дос­туп­ное для чте­ния и за­пи­си. Для шаб­ло­нов с фла­гом g это свой­ст­во со­дер­жит но­мер по­зи­ции в стро­ке, с ко­то­рой дол­жен быть на­чатсле­дую­щий по­иск. Как опи­са­но ни­же, оно ис­поль­зу­ет­ся ме­то­да­ми exec() и test().
	Конструктор RegExp - принимает один или два аргумента. Первый аргумент строка, преабразуемая в регулярное выражение, слеши нужно экранировать. Второй аргумент принимает флаги. Удобно использовать когда регулярные выражения необходимо создавать динамически.
	- regExp.exec(testLine)																- работает как match, принимает обрабатываемую строку. Если не найдено совпадения, возращает- null, если найдено совпадение возращает такой-же массив как и match без флага g(всегда). Если установлен флаг- g, у объекта regExp- появляется свойство- lastIndex. Если соответствия нет- lastIndex = 0;
	- regExp.test(testLine)																- возращает true, если есть совпадание. Может работать с флагом g. Если есть g тогда появляется свойство lastIndex.

Подмножества и расширения js:
	- const																					- определяет константу, изменения значения игнорируются а объявление такой-же переменной (константы) вызывает исключение. (в JS_6)
	- let																						- как var, объявляя(в JS_6) переменная объявленная let - действует только внутри блока где она была объявленна (как в c++). Остальные из этого учебника не актуально.
	Присваивание с разложением															- var [x, y] = [1, 2]; [x, y] = [x + 1, y + 1]; -> x=2, y=3 [x, y] = [y, x]; -> x=3, y=2. ко­ли­че­ст­во пе­ре­мен­ных сле­ва и с права не обязательно долж­ны сов­па­дать. Лиш­ние пе­ре­мен­ные сле­ва по­лу­чат undefined, а лиш­ние спра­ва бу­дут иг­но­ри­ро­вать­ся. В цепочке присваивания используется структура данных справа. let first, second, all; all = [first,second] = [1,2,3,4]; -> first=1, second=2, all=[1,2,3,4]. Можно и так let [one, [twoA, twoB]] = [1, [2,2.5], 3]; // one=1, twoA=2, twoB=2.5. Разложение можно производить с объектами и смешанными структурами.

КЛИЕНТСКИЙ JAVASCRIPT
	Про­грам­мы на язы­ке Ja­va­Script мо­гут ма­ни­пу­ли­ро­вать со­дер­жи­мым до­ку­мен­та че­рез объ­ект Document и со­дер­жа­щие­ся в нем объ­ек­ты Element. Они мо­гут из­ме­нять ви­зу­аль­ное пред­став­ле­ние со­дер­жи­мо­го, управ­ляя сти­ля­ми и клас­са­ми CSS, и оп­ре­де­лять по­ве­де­ние эле­мен­тов до­ку­мен­та, ре­ги­ст­ри­руя со­от­вет­ст­вую­щие об­ра­бот­чи­ки со­бы­тий.

	Кли­ент­ский Ja­va­Script-код мо­жет встраи­вать­ся в  HTML-до­ку­мен­ты че­тырь­мя спо­со­ба­ми:
	•	 встро­ен­ные сце­на­рии ме­ж­ду па­рой те­гов <script> и </script>;
	•	 из внеш­не­го фай­ла, за­дан­но­го ат­ри­бу­том src те­га <script>;
	•	 в об­ра­бот­чик со­бы­тия, за­дан­ный в ка­че­ст­ве зна­че­ния HTML-ат­ри­бу­та, та­ко­го как onclick или onmouseover;
	•	 как те­ло URL-ад­ре­са, ис­поль­зую­ще­го спе­ци­аль­ный спе­ци­фи­ка­тор псев­до­про­то­ко­ла Ja­va­Script: (bookmarklet).
	- async defer																			- атрибуты <script>, сообщают браузеру что скрипт, содержащий атрибут src- не вносит изменение в document. defer- ждет формирования document и затем выполняется по порядку. async- асинхронный, так-же можно создать(подключить) скрипт динамически
	Со­бы­тия име­ют име­на, та­кие как click, change, load, mouseover, keypress или readystatechange
	- addEventListener('type', func, bool)											- позволяет безопасно повесить на элемент множество обработчиков. bool == true -> регестрирует обработчик для перехвата, false - всплытие (по умолчанию)
	- document.readyState																- имеет значения: loading or interactive or complete (нестандартизированны)
	- document.compatMode																- определяет режим отображения браузером (режим совместимости css)- 'CSS1Compat'- включен, 'BackCompat' или undefined- выкл
	- <a href='javascript:alert(new Date())'>Сколько время</a>				- скрипт можно запускать из самой url

	WINDOW
	
	- тыймеры -
	- setTimeout(f, time), setInterval()											- выполняются асинхронно, отложенный вызов, interval будет зациклен. Возращают значение которое можно передать в clearInterval
	- clearInterval(h)																	- отменяет планируемый запуск setTimeout и setInterval
	
	- document.URL и location.href или toString()								- содержит текущий url (есть какая-то разница между 1 и 2)
	location имеет всойства protocol, host, hostname, port, pathname, search и hash. location.search- возращает get часть вместе со знаком вопроса и доступен для записи.
	- location.replace('host')															- открывает новую страницу(не сохраняет историю) как и простое приравнивание- location = 'http://google.com'
	- location.assign																		- (сохраняет)
	- location.reload()																	- перезагрузить документ
	- location = '#top'																	- переход в блок id=top этого окна
	- window.history																		- хранит историю посещений, но из-за безопасности их получить нельзя. Есть методы back(), forward(), go(num) - если num положительный, то на это количество страниц вперед и наоборот.
	- window.navigator																	- хранит много всякой инфы о браузере, операционке и т.п. window.navigator.online- bool значение подключения браузера к нету.
	- window.screen																		- хранит инфу об характеристиках экрана.
	
	- диалоги -
	- alert()																				- выводит сообщение
	- confirm()																				- предлагает два вариантаб возращает bool результат (да/нет)
	- promt()																				- предагает ввести строку, возращает строку введенную пользователем.
	- showModalDialog()																	- выаодит модальное окно. Можно настроить (не работает кажись)
	
	- обработка ошибоок -
	- window.onerror																		- обработчик события, когда неабработанное исключение дошло до вершины стека. Возращаемое return-значение(bool) функции говорит об обработанности ошибки. обработчик верхнего уровня(window) получает три параметра: текст ошибки, домен, номер строки ошибки.
	- Элемент документа как свойство окна - все элементы имеющие id становятся неперичислимыми свойствами глобального объекта, если в глобальном объекте нет таких свойств. Элементы <a> <applet> <area> <embed> <form> <frame> <frameset> <iframe> <img> <object> с атрибутом name ведут себя подобным образом. Если атрибут name и (или) id, имеет повторяющееся значение, то одноименное свойство window будет содержать массивоподобный объект со всеми элементами.
	
	- окна -
	- window.open(url, name, param, bool)											- открывает новую вкладку(окно) с указанным url(если не задано, то открывает about:blank), и задает новому объекту window.name = name, усли не заданно, то имя '_blank'; param(необязательный)- определяет размеры окна и отображаемые панели(если задан то обычно приводит к открытию нового окна). param- нестандартизирован и html5- требует его игнорировать. bool- если второй аргумент определяет имя существующего окна, то при true заменяет запись истории нового окна(не получилось). Значением возращаемым open() является ссылка на созданный объект window(новой вкладки (окна)). name - может использоваться в <a target> и <form target>
	-	window.opener																		- ссылается на объект window создавшее данноое окно, если окно window- родительское(базовое), то opener=null. Если window.opener == window-родителя, то при запуске window.open() родителя окно заново не окрывается
	- window.close()																		- закрывает окно через ссылку newWindow.close(), объект window по прежнему доступен, его свойство closed = true, а document = null;

	- фреймы - 
	- iftame.contentWindow																- window у фрейма
	- parent																					- ссылается на вмещающее окно фрейма
	- window.frames[i]																	- доступ к фрейму (его окну), из содерщащего фрейм окна
	- frames.iframeName																	- доступ к фрейму (его окну) по имени, из содерщащего фрейм окна
	- window.top																			- окно верзнего уровня
	Если src фрейма ссылается на другой домен, то доступ к document фрейма ограничен

	DOCUMENT

	DOM(объектная модель документа) - представляет прикладной програмный интерфес (API) для работы с HTML и XML
	выбрать элемент документа можно:
		*	по id																				- document.getElementById('idName'). В IE8 работает без регистра и возращает элементвы с таким name
		*	по значению атрибута name													- getElementsByName('name'). этот метод определен не классом Document, а HTMLDocument -> работает только с html-документами. Возращает объект NodeList (ведет как массив объкектов Element только для чтения). Name можно применнять к form, (input-), img, iframe, applet, embed, object(без вложеных объектов) и все они создают свйство в document с этими именами (кроме инпута). Если существует только один элемент, то имени свойства присвоится Element, иначе NodeList. Свойство iframe ссылается не на Element, а на его объект Window. Но доступ лучше получать через getElementByName. элементы с указанным именем включаются в том-же порядке.
		*	по имени тега																	- getElementsByTagName - вернет массивоподобный объект(только чтение) класса NodeList, элементы с указанным дескриптором включаются в том-же порядке. Класс Element так же имеет этот метод -> можно применить так el.getElementsByTagName('p')-> вернет все дочерние элементы. HTMLDocument определяет images, forms, links которые содержат img, form, link(с атрибутом href)-> можно обращатся document.links[0] или если есть id || name -> document.links[id(name) ссылки].
		Так-же определенны document.head, document.body, document.documentElement(содержит элемент <html>)
		*	по css классу																	- getElementsByClassName(args)- как tagName, но можно передать много(через пробел) аргументов (порядок не важен). В зависимости от режима совместимости браузера, аргументы метода нерегистрозависимы(режим совместимости), регистрозависим(стандартный режим);
		*	по css селектору																- querySelectorAll(arg) - позволяет аргументом применять css-селекторы. Возращает объект NodeList(неживой) или null. Если arg недопустимая строка - возбудит исключен
																								- querySelector(arg) - возращает первый элемент удовлетворяющий условию или null
		Эти два метода определяются и в Element. Нельзя получить :visited, :link(т.к. можно собрать историю росещений пользователя)
	- document.all																		- устаревший прикол (выведет все узлы кроме Text в массивоподобном объекте)
	
	Массивоподобные объекты HTMLDocument и NodeList								- доступны для чтения, непосредственно нельзя вызывать методы array, но можно вызывать косвенно. Объекты не являются слепками и изменяются динамически если добавляются (удаляются) элементы в документе. Если делать изменения в цикле, следует сделать слепок var copy = Array.prototype.slice.call(nodelist, 0);

	Node
		Document
			HTMLDocument
		CharacterData
			Text
			Comment
		Element
			HTMLElement
				HTMLGeadElement, HTMLBodyElement, HTMLTitleElement, HTMLParagraphElement, HTMLInputElement, HTMLTableElement, ...etc.
		Attr

	Document можно представить как дерево объектов Node. Есть дерево объектов Element. Node получает доступ ко всем узлам (коментарии, текста, переносы строк) !

	- документы как деревья узлов -
	- parentNode																			- ро­ди­тель­ский узел дан­но­го уз­ла или null для уз­лов, не имею­щих ро­ди­те­ля, та­ких как Document.
	- childNodes																			- дос­туп­ный для чте­ния объ­ект, по­доб­ный мас­си­ву (NodeList), обес­пе­чи­ваю­щий «жи­вое» пред­став­ле­ние до­чер­них уз­лов.
	- firstChild, lastChild																- пер­вый и по­след­ний до­чер­ние уз­лы или null, ес­ли дан­ный узел не име­ет до­чер­них уз­лов.
	- nextSibling, previousSibling													- сле­дую­щий и пре­ды­ду­щий брат­ские уз­лы
	- nodeType																				- Тип дан­но­го уз­ла. Уз­лы ти­па Element- зна­че­ние 1. Тек­сто­вые уз­лы ти­па Text- зна­че­ние 3. CDATASection- 4. Уз­лы ти­па Comments- зна­че­ние 8. Уз­лы ти­па Document име­ют зна­че­ние 9. Уз­лы ти­па DocumentFragment- зна­че­ние 11.
	- nodeValue																				- Тек­сто­вое со­дер­жи­мое уз­лов Text и Comment. (Чтение, запись)
	- nodeName																				- Имя те­га эле­мен­та Element, в ко­то­ром все сим­во­лы пре­об­ра­зо­ва­ны в верх­ний ре­гистр.

	- документы как деревья Element -
	- children																				- нестандартизированно (реализованно во всех? браузерах)
	- firstElementChild, lastElementChild											- аналогичны firstChild, lastChild в Node
	- nextElementSibling, previousElementSibling									- аналоги Node
	- childElementCount																	- равносильно children.length

	- Атрибуты -
	HTMLElement определяет свойства для чтения и записи аттрибутов элементов. В js эти свойства называются так-же + нижний регистр. Tсли несколько слов, то CamelCase, если ключевое слово - то в начало добавляется html (for -> htmlFor, class -> className (исключение)). Свойства обычно имеют текстовые значения, но могут быть bool и числовые. Обработчики имеют тип function. Атрибит form внутри input имеет тип - Element. Аттрибут style имеет тип cssStyleDeclaration
	- elem.getAttribute('attr')														- метод HTMLElement возращает значение атрибута, имя атрибута указывается как в html(даже если ключевое слово js), возращает только строку. Работает и с xml
	- elem.setAttribute('attr', 'value')											- seter предыдущего. Вторым строчным аргументом передается значение атрибута.
	- element.hasAttribute()															- метод Element, проверяет наличие атрибута в элементе
	- element.removeAttribute()														- удаляет атрибут
	- getAttributeNS(), setAttri­buteNS(), hasAttributeNS() и  removeAttributeNS()
																								- для работы с атрибутами xml у которых используется пространство имен
	В html5, считается допустимым использование нестандартного атрибута, начинающегося с 'data-', а у элементов есть свойство dataset из которого можно получить значения 'data-'. Пример <div id="el" data-x="10"></div> el.dataset.x -> 10 Свойства с дефисом data-jquery-test, отобразится dataset.jqueryTest. св-ва Dataset - живые, если удалить, то исчезнет и у элемента.

	- attributes																			- живое свойство объектов класса Node. Для объектов Element возращает объект подобный массиву для чтения со всеми аттрибутами элемента, если применяется не к Element, возращает null. Свойства являются объектами класса Attr.
	- innerHTML																				- возращает внутреннее содержание в виде строки разметки. Доступно ля записи. Работает с XML. Работает с element
	- outerHTML																				- возращает внутренне содержимое и обрамляющие дискрипторы. Доступно для записи(переписывает и дескриптор).
	- insertAdjacentHTML(arg1, arg2)													- вставляет произвольную строку в прилегающую к указанному элементу. Первым аргументом передается место прилегания before­begin, afterbegin, beforeend, afterend. Второй аргумент- передаваемая строка
	- textContent																			- свойство доступное для записи элемента Element. Аналагичен innerHTML, сохраняет как обычный текст '<&' и т.п.
	- innerText																				- с некоторым отличием, аналагичен textContent. Не возращает содержимое script. Для некоторых элементов таблиц- доступен только для чтения.
	<script type='fignya'> не заработает, но данные внутри не отобразятся пользователю (отобразятся в дереве DOM), но их можно использовать получая доступ через innerText(HTML) и др и из аттрибутов. Есть свойство text.
	- data																					- свойство класса CharacterData, потомки которого- Text и CDATASection. Аналогичен nodeText

	- Создание узлов -
	- document.createElement()															- Метод Document. Создает элемент, аргументом передается дескриптор. HTML- не чувствительный к регистру. XML-чув.
	- document.createTextNode()														- Аналог метода выше. Создает текстовый узел
	- document.createComment()															- -//- Создает коммент
	- document.createDocumentFragment()												- разновидность Node, временный контейнер для узлов. Его parentNode возращает null. При вставке этого контейнера в документ, передаст все свои дочерние элементы и опустеет.
	- document.createElementNS()														- Позволяет использовать пространство имен XML (что за оно- хз)
	- cloneNode()																			- Метод Node. Создает копию узла. Если 2 аргументом передать true- скопируются все потомки узла, иначе нет.

	- Вставка узлов и замена -
	- appendChild()																		- Вызывается узлом(Node) и вставляет переданный арг-том узел последним дочерним узлом(значение св-ва lastChild)
	- parent.insertBefore()																- получает 2 арг-та. 1й-узел который надо вставить. 2-узел перед которым надо вставить(если null, то appendChild), вызывается из родимтеля 2-го аргумента.
	Если appendChild или insertBefore вставляют элемент, который уже есть в документе, элемент будет удален из документа и вставлен в новое место.

	- Удаление узлов и замена-
	- removeChild()																		- удаляет элемент из DOM. Метод должен вызываться относительно родителя -> n.parentNode.removeChild(n)
	- replaceChild()																		- заменяет элемент переданным элементом. 1й аргумент- новый элемент, 2- удаляемый. Вызывается из родителя

	- Прокрутка документа, координаты -
	2 системы координат: система координат документа, система координат видимой области. Обработчики от мыши работают с координатами видимой области
	- window.pageXOffset (Y)															- определяет прокрутку документа (положение относительно верхнего левого угла документа). В IE <= 8- не работает
	- document.documentElement.scrollTop (Left)									- -//-. Работает в IE <= 8 в нормальном режиме.
	- document.body.scrollTop (Left)													- -//-. Работает в IE <= 8 в режиме совместимости.
	- window.innerHeight (Width)														- возращает высоту (ширину) видимого окна для IE > 8 (с полосой прокрутки)
	- Element.clientWidth (Height)													- -//-. Для IE <= 8 (Нормальный режим). (чистый размер элемента)
	- Element.getBoundingClientRect()												- возращает объект со свойствами left right top bottom (width, height не являются стандартизированными, нет в IE)
	Включают отступы(padding), рамки(border). Поля(margin) - не включает
	- Element.getClientRects()															- для строчных элементов возращает массивоподобный объект, результаты getBoundingClientRect для каждой строки
	Не являются "живыми" объектами
	- document.elementFromPoint()														- принимает координаты X, Y и возращает element который самый внутренний (в DOM-дереве) и самый верхний (z-index) (работает с видимой областью, если координаты не попадают в видимую область, вернет null). События мыши содержат координаты в аттр target -> этот метод редко используется
	- window.scrollTo() (синоним scroll())											- прокручивает область видимости на заданные координаты (x, y) = document.body.scrollTop + doc.b.scrollLeft
	- window.scrollBy()																	- прокручивает область относительно действительной области
	- element.scrollIntoView()															- скролит экран к элементу (стараясь проскролить верхнюю часть видимого окна к верхней части переданного элемента), если аргументом передать false- то выровняет по низу. Схож с window.location.hash, когда ему присваивают имя якорного элемента <a name="">

	Все html объекты имеют всойства:													( доступные только для чтения и работают в устаревших браузерах )
	- offsetWidth																			- ширина элемента
	- clientWidth																			- offsetWidth, только без рамок(margin) и не включают полосы прокрутки (если они есть). Для строчных вернет 0
	- scrollWidth																			- определяет полную (не только видимую ширину)
	- offsetHeight
	- clientHeight																			- offsetHeight, только без рамок(margin) и не включают полосы прокрутки (если они есть). Для строчных вернет 0
	- scrollHeight
	- offsetLeft
	- clientLeft																			- вернет расстояние между краем margin и border. Если слева полоса прокрутки, то она входит в значение
	- scrollLeft																			- доступно для записи
	- offsetTop
	- clientTop																				- вернет расстояние между краем margin и border. Если сверху полоса прокрутки, то она входит в значение
	- scrollTop
	- offsetParent
	Что-бы не осуществлять множество проверок, можно применить библеотеку, например jquery

	- forms -
	объект form имеет свойства elements, action, encoding, method, target. Так же есть метода submit() и reset()
	У элементов form есть следующие св-ва:
	- type																					- св-во доступно только для чтения
	- form																					- для чтения ссылка на элемент form, null если не находится внутри элемента form
	- name																					- для чтения, возращает name
	- value																					- и записи. Text и textarea содержат введеный текст. Для кнопок input- текст кнопки. radio не редактируется
	Если onsubmit-у формы вернуть false, то форма не отправится. Onsubmit формы вызывается только в случае нажатия кнопки submit. С reset аналагично.
	- blur																					- событие потери фокуса с элемента формы
	При событии элементов форм this указывает на элемент формы вызвавший событие. А каждый элемент имеет ссылку на form -> можно обратится this.form
	buttom отличается от <input type='button', тем что значение прописывается внутри тега, а в инпуте в value
	- radio, checkbox -
	флажки и чекбоксы обычно имеют одинаковый атрибут name, при обращении к ним по имени возращается массивоподобный объект. И те и другие имеют св-во checked (доступно для чтения и записи). Свойство defaultChecked определяет должен ли объект быть checkeed при первой загрузке. Value можно изменить, что изменить строку отправляемую на сервер. Радиокнопка изменяющая значение при нажатии на другую кнопку не вызывает событие onchange.
	- file -
	Св-во value доступно только для записи (защита от злоумышленников)
	- select -
	Если select multiple, тогда type объекта select -> select-multiple, иначе- select-one
	- selectIndex																			- (select-one) определяет выбранный элемент. в multiple для определения надо проверить все options на selected
	- text и value объекта option доступно для записи
	option не имеет обработчиков. Для обработки событий использовать onchange-selectа
	в options имеется возможность вставки и удаления элементов option. Для этого в элементу массиве options присвоить null. Остальные элементы сдвинутся. Создание элемента option: var option = new Option('text', 'value', defaultSelected(bool), selected(bool));
	- еще свойства document -
	- cookie																					- позволяет читать и писать cookie
	- domain																					- позволяет ослаблять ограничения политики общего происхождения между 2мя серверами
	- lastModified																			- дата последнего изменения документа
	- location																				- location объекта window
	- referrer																				- URL-ад­рес до­ку­мен­та, со­дер­жа­ще­го ссыл­ку (ес­ли су­ще­ст­ву­ет), ко­то­рая при­ве­ла бро­узер к те­ку­ще­му до­ку­мен­ту. Это свой­ст­во име­ет то же зна­че­ние, что и HTTP-за­го­ло­вок Referer, но за­пи­сы­ва­ет­ся с дву­мя бу­к­ва­ми r.
	- title																					- возращает title документа
	- URL																						- стро­ка, дос­туп­ная толь­ко для чте­ния, а не объ­ек­т Location. свой­ст­ва сов­па­да­ет со зна­че­ни­ем свой­ст­ва location.href, но, в от­ли­чие от объ­ек­та Location, не яв­ля­ет­ся ди­на­ми­че­ским. Ес­ли поль­зо­ва­тель вы­пол­нит пе­ре­ход, ука­зав но­вый иден­ти­фи­ка­тор фраг­мен­та внут­ри до­ку­мн­та, то свой­ст­во location.href из­ме­нит­ся, а свой­ст­во document.URL – нет.
	- document.write()																	- добавляет содержимое в документ. Можно использовать во время синтаксического анализа документа. Если после- создаст новый document со строкой созданной функцией. Также нельзя использовать в сценариях с атрибутом async и defer. Создержимое write может буферизировать(накапливаться) пока не будет вызван завершающий вызов close() документа. Есть версия метода writeln()- с переводом строки
	- window.getSelection()																- ES5 функция, определяет какая часть текста документа выделенна. window.getSelection().toString(). Не работает в текстовых input-ах
	- document.selection()																- -//- для IE. document.selection().createRange().text
	- contenteditable																		- атрибут дескрипторов, разрешает пользователю редактировать содержание. Можно установить с помощью js
	- spellcheck																			- атрибут элемента для проверки правописания, spellcheck=false запрещает проверку
	- document.designMode = 'on'														- установит весь документ доступный для режима редактирования
	- document.execCommand()															- выполняет команду, переданную первым аргументом, для редактирования выделенных областей. Некоторые команды: bold, insertLineBreak, selectAll, createLink, insertOrderedList, subscript, delete, insertUnorderedList, superscript, formatBlock ,insertParagraph, undo, forwardDelete, insertText, unlink, insertImage, italic, unselect, insertHTML, redo

16 CSS

	при работе с отличающимися префиксами нестандартных св-в, можно определить css класс
	.radius10{
		-webkit-border-radius: 10px;
		-moz-border-radius: 10px;
		-ms-border-radius: 10px;
	}
	поле рамка отступ - margin border padding
	При блочной мадели свойство width, height определяют растояние не включающее отступы, рамки и поля. top и left внутреннего абсолютно спозицианированного элемента задают расстояние от внутренней стороны рамки объемлющего элемента до внешней стороны рамки внутреннего элемента.
	box-sizing: content-box(default), border-box. border-box - учитывает рамку и отступы. Удобно когда элемент в % а рамка с отступами в пикселях. Но можно обойтись calc() css.
	
	- Встроенные стили -
	- element.style																		- представляет собой объект класса CSSStyleDeclaration. Значение свойства должно быть текстовой строкой. e.style.fontSize = '24px';
	- e.style.cssText (e.setAttribute('style', prms)), (e.getAttribute)	- установить или получить встроенные стили
	Наименование свойств CSSStyleDeclaration немного отличается от css-свойств: 1) вместо дефисов (js интерпритирует как минус) - CamelCase. Если зарезервированное слово js (Float например) добавляется приставка CSS.

	- Вычисленные стили -
	- window.getComputedStyle(element, null)										- Получить вычисленный(только для чтения) стиль. Второй аргумент (обязательный) может-быть (:before :after :first-line :first-letter). Вместо null можно писать ""

	Свойства вычисленного стиля доступны только для чтения, имеют абсолютные значения (любые свойства размера будут вычисленны в пикселях, цвета в rgb или rgba), короткая форма свойств не вычисляется (не актуально на данный момент), cssText - не определено.

	- css-классы -
	- el.className																			- выводит строку (неживая), содержащую все классы элемента
	- el.classList																			- получает живой массивоподобный объект DOMTokenList (только для чтения), который содержит имена классов и методы remove, add, toggle;
	- el.classList.remove																- удаляет отдельное имя класса, если оно есть
	- el.classList.add																	- добавляет имя класса, если такого нет
	- el.contains																			- проверяет наличие класса
	
	- document.styleSheets																- выводит массивоподобный объект (только для чтения) CSSStyleSheet. В нем содержатся таблицы css (пути и др.)
	- disabled																				- отключает стили (el.disabled = true). Применим к элементам style, link и объекту CSSStyleShet

	- получение, вставка и удаление правил из таблиц стилей -
	Для работы необходимо создать элемент style и получить его styleSheet
	- document.styleSheets[0].cssRules[0]											- должно вывести первое правило, первой таблицы css
	- document.styleSheets[0].insertRule("H1 {text-weight: bold;}", 0);	- должно добавить правило в css таблицу
	- deleteRule																			- удаляет

17 Обработка событий
	При возбуждения события, в функцию обработчик передается объект события event (либо передать первым аргументом) со всеми свойствами события. В частности event.type (тип события), event.target - элемент на котором вызвалось событие.

	- категории событий -
	- аппаратно-зависимые события ввода:			mousedown, mousemove, mouseup, keydown, keypress, keyup, touchmove, gesturechange
	- аппаратно-независимые события ввода:			click(так как не привязан именно к мышке, можно с клавы и touch телефона), textinput
	- события пользовательского интерфейса:		focuus, change, submit, (события форм).
	- события изменения состояния:					load, DOMContentLoaded(загрузка всего html и постройка DOM-дерева), popstate (кнопка "Назад" браузера), online, offline, readystatechange, lo­ad­start, progress и loadend (события загрузки выбранного пользователем файла)
	- прикладные события:								dragstart, dragenter, dragover и drop - буксировка элементов мышью. waiting, playing, se­ek­ing, volumechange и т.д. (события <video>,<audio>)
	- об­ра­бот­чи­ки оши­бок и со­бы­тий от тай­ме­ров:	являются частью асинхронной работы и похожи на обработчики обычных событий.

	- события форм -
	некоторые - submit, reset, click, change(при вводе, выполняется после снятия фокуса), focus, blur(выход фокуса) рассматривались в 15.9.3. Все события форм всплывают, кроме focus и blur

	- события window
	- load (всплывает только до Document), DOMContentLoaded(загрузка html + формирование dom-дерева), readystatechange, unload(перед закрытием документа, не дает отменить закрытие документа), beforeunload(задает вопрос перед закрытием документа), onerror (см. выше). error и load возможно настроить для отдельного элемента (загрузка или ошибка загрузки ресурса). abort (когда происходит отмена загрузки ресурса пользователем). focus, blur также работают и объектом window (окно браузера в фокусе). resize, scroll (изменеие окна браузера, скролл) scroll работает и с элементами (не всплывает)

	- события мыши -
	Все события мыши всплывают, кроме mouseenter mouseleave
	- click, contextmenu, dblclick, mousedown, mouseup, mousemove, mouseover, mouseout, mouseenter, mouseleave, mousewheel, wheel(новее)
	Событие по умолчанию для click при нажатии кнопки отправки формы и ссылки, можно отменить. Событие contextMenu, так-же можно отменить, но не во всех браузерах.
	- click																					- Похож на mousedown + mouseup, но также работает и на сенсорных экранах
	- mouseover																				- вход в элемент. relatedTarget указывает из какого элемента совершен вход.
	- mouseout																				- выход из элемента. relatedTarget куда переходит курсор
	event.which(button) -> нажатая клавиша мыши; altKey, ctrlKey, metaKey и shiftKey -> true, в мо­мент воз­ник­но­ве­ния со­бы­тия удер­жи­ва­лась на­жа­той со­от­вет­ст­вую­щая кла­ви­ша-мо­ди­фи­ка­тор; detail -> одинарный, двойной, тройной щелчок.

	- события клавиатуры -
	Генерируются в любом месте где может быть установленн фокус (даже окно браузера) и всплывает вверх.
	- keydown, keypress(похоже как будто генерируется после keydown, но перед keyup), но более высокоуровневое
	- textinput и альтернативный textInput											- событие связанное с вводом теста(любым способом: из буфера, перетаскиванием)
		- event.data																		- содержит введенный текст
		- event.inputMethod																- (может быть не реализован) должно определять способ ввода
	«textinput», «textInput» и «keypress» мож­но от­ме­нить, что­бы пре­дот­вра­тить ввод сим­во­ла, событие input не позволяет этого сделать.

	- события модели DOM -
	- focusin, focusout (всплывающая альтернатива focus, blur), mouseenter, mouseleave (невслывающая альтернатива mouseover, mouseleave)
	- wheel, textInput(возбуждается при любом виде ввода: клавиатура, вставка из буфера, перетаскивание и содержит в свойстве введенный блок текста)

	- события html5 -
	- <audio>, <video>:																	- canplay, loadeddata, playing, stalled, canplaythrough, loadedmetadata, progress, suspend, durationchange, loadstart, ratechange, timeupdate, emptied, pause, seeked, volumechange, ended, play, seeking, waiting. Объект события не имеет спец. свойств, но имеет всойство target, которое имеет множество всойств и методов.
	- drag-and-drop																		dragstart, drag, dragend, dragenter, dragover, dragleave, drop
	- hashchange, popstate(вперед, назад. История), invalid(не прошедшее валидацию поле формы)
	- offline, online(генерируются во время обыва или соединения интернет соединения). Дополнительные события: cached, checking, downloading, error, noupdate, obsolete, progress, updateready
	- message ис­поль­зу­ет­ся мно­же­ст­вом API для ор­га­ни­за­ции асин­хрон­ных взаи­мо­дей­ст­вий. По­зво­ля­ет сце­на­ри­ям в до­ку­мен­те с од­но­го сер­ве­ра об­ме­ни­вать­ся со­об­ще­ния­ми со сце­на­рия­ми в до­ку­мен­те с дру­го­го сер­ве­ра. Это да­ет воз­мож­ность без­опас­но обой­ти ог­ра­ни­че­ния по­ли­ти­ки об­ще­го про­ис­хо­ж­де­ния
	- XMLHttpRequest, FileReader														- ход выполнения асинхронной загрузки
	- loadstart, progress, loadend, load, error, abort							- AJAX
	- storage																				- Web Storage API
	- beforeprint, afterprint															- до(после) печати (не должна применятся для изменения представления документа, для этой цели есть css директивы)

	- события сенсорного экрана -
	- orienta­ti­on­change(d)																- поворот экрана
	- gesturestart(начало), gesturechange(выполнение), gestureend(конец)	- сыбытие изменения масштаба или вращения двумя пальцами
	- touchstart, touchmove, touchend												- начало, выполнение и конец прикосновения

	- Регистрация обработчиков -
	1: создать свойство объекта с именем события с приставкой on (oninput)
	2: вызвать метод addEventListener()
	3: установить обработчик через атрибут дескриптора
		Если в качестве атрубита создается обработчик события, браузер преобразует сроку в такую функцию
			function(event){
				with(document){
					with(this.form || {}){
						with(this){
							//код js
			}	}	}	}
	Если событие применяется к window (afterprint, focus, online, resize, beforeprint, hashchange, pagehide, storage, beforeunload, load, pageshow, undo, blur, message, popstate, unload, error, offline, redo), то обработчик необходимо применять к атрибуту у body
	- addEventListener(even, func, bool)											- Позволяет подключить множество слушателей событий. Передается три (два) аргумента. Тип слушателя, без приставки on, функция, и третий, по умолчанию (false), но если установить true - функция будет перехватывающий обработчик и будет вызванна в другой фазе распространения события.
		- e.cancelBubble = true															- запретить дальнейшее всплытие
		- e.preventDefault()																- запрет выволнения обработки по умолчанию
	- removeEventListener																- должен получить те-же аргумента что и addEventListener и удаляет слушатель
	- отмена события -
	Если обработчик события, созданный через свойство объекта или через атрибут, возращает false, то браузер не должен выполнять событие по умолчанию. Если через метод addEventListener - то нужно установить event.preventDefault(), если через attachEvent() -> window.event.returnValue = false;(отмена события)
	- Порядок вызова: 1) обработчик через свойство или через атрибут 2) addEventListenerы по очереди регистрации. 3) AttachEvent(IE) вызываются в произвольном порядке
	- Три фазы обработки события:
		1)	Фаза перехвата. Распространяется от Window к DOM-листьям, Перехватывающий обработчик целевого объекта не вызывается (остальные вызываются)
		2) Вызов обработчика
		3) Фаза всплытия
	- stopPropagation()																	- метод, отменяет распространение события, если в элементе вызова stopPropagation есть еще обработчики, то они выполнятся, дальше по всплытию (перехвату) - не выполнятся.
	- stopImmediatePropagation()														- как stopPropagation(), но отменяет распространение события, даже у остальных обработчиков внутри элемента

	- События загрузки документа -
	- window.load																			- вызывается после полной загрузки html, выполнения отложенных сценариев, и загрузки всех изображений.
	- window.DOMContentLoaded															- вып. после загрузки html с синтаксическим анализом и загрузки отложенных сценариев. async js и изображения могут продолжать загружаться.
	- readystatechange																	- событие изменения состояния загрузки документа (readyState). Значения: loading, interactive, complete

	- drag and drop -
	- Источники -
	- Для создание механизма DnD, необходимо минимум два элемента: источник и приемник. Приемник создается путем добавления отрибута draggable со значением true, вызывающий событие dragstart. Событие dragstart похоже на событие мыши, но у него есть свойтсво dataTransfer, которое ссылается на объект DataTransfer, определяющее методы и свойства API DnD. Возможно потребуется установить свойство dataTransfer.effectAllowed что-бы определить тип операции (перемещение, копирование, сощдание ссылки). Когда выполняется сброс, срабатывает событие dragend - в котором нужно проверить свойство dataTransfer.dropEffect - что-бы убедиться, действительно ли произведена операция перемещения.
	- dragstart																				- событие начала перемещения приемника
	- dragend																				- событие сброса
	- event.dataTransfer.setData('text', data)									- Устанавливает передоваемые данные от источника
	- event.dataTransfer.types															- выводит массив (массивоподобный элемент, зависит от браузера) передаваемых типов
	- event.dataTransfer.types.contains('text/plain')							- html5, проверяет наличие передаваемого типа.
	- event.dataTransfer.types.indexOf('text/plain')							- альтератива предыдущего
	- event.dataTransfer.setDragImage(image)										- Устанавливает изображение перетаскивания, где image element изображения
	- Приемники -
	- Приемником может быть любой элемент документа и для него не обязательно добавлять атрибут draggable (но при реализации API html5 добавить атрибут dropzone). В приемнике возбуждается 4 события:
	- dragenter																				- всплывает. Когда буксируемый элемент оказывается над приемником, отменяя событие сообщает браузеру, что он готов принять объект и вызывается событие dragover
		- dataTransfer.types																- определяет, содержит ли буксируемый элемент данные в формате, понятные приемнику, при этом может стать необходимым проверить свойство dataTransfer.effectAllowed
	- dragover																				- буксировка элемента над приемником, необходимо отменить событие (вернуть flase), для вызова след. события
	- dragleave																				- всплывает .Если буксируемый элемент покинул область приемника. Отменить событие после всех необходимых действий
	- drop																					- если сброс произошел над приемником
		- dataTransfer.getData()														- получить передаваемые данные
		- dataTransfer.files																- если пользователь передаст файл или несколько файлов, будет содержатся массивоподобный элемент с файлами(ом)

18	Работа с HTTP
		AJAX - позволяет инициализировать клиентом обмен данными с сервером без перезагрузки страницы. Comet - позволяет тоже-самое, но со стороны серевера. XMLHttpRequest поддерживает любые текстовые форматы, может подерживать HTTP/HTTPS и др. протоколы. XMLHttpRequest - класс. Каждый экземляр представляет 1 запрос/ответ. (XHR) - является прикладным интерфейсрм уровня браузера (браузер сам заботится о cookies, переадресации, кэшировании, прокси-серверах)
	1
	- var request = new XMLHttpRequest();											- создание объекта прикладного интерфейса XMLHttpRequest. Допустимо использовать повторно, но отправленный до этого запрос прервется. В IE версии 5, 6 доступен в виде active-x объекта.
	2
	- request.open('GET', 'data.csv', [bool]);									- 1 аргумент устанавливает метод доступа (не чувствителен к регистру). Get используется, когда запрос не имеет побочных эффектов и когда отвтет сервера можно поместить в кэш. Если при одинаковом запросе возращаются одинаковые ответы или есть побочный эффект, следует использовать POST. 2 аргументом передается относительный адрес серверной страницы. Можно передать и абсолютный путь, в таком случае протокол и домен и номер порта должны совподать, исключение - если сервер явно разрешил обращение к стороннему ресурсу. 3 - если передать false, то метод send() будет выполнен в синхронном режиме и вернет результат (без слушателей событий)
		GET, POST, DELETE, HEAD, OPTIONS, PUT поддерживаются XMLHttpRequest
	3
	- r.setRequestHeader('Content-type', 'text/plain;charset=UTF-8')		- Установка заголовков запроса, если это необходимо (если GET то необязательно). POST обычно содержит 'Content-Type' Не долж­ны пе­ре­да­ваться мето­ду setRequestHeader() сле­дую­щие за­го­лов­ки: Accept-Charset, Content-Transfer-Encoding, TE, Accept-Encoding, Date, Trailer, Connection, Expect, Transfer-Encoding, Content-Length, Host, Upgrade, Cookie, Keep-Alive, User-Agent, Cookie2, Referer, Via. Можно передать данные (например логин, пароль) 4 и 5 аргументом.
	4
	- request.send(null)																	- Отправка запроса. Если Get, то он не содержит тела, а аргумент null(можно опустить).
	
	- события и получение ответа-
	- readysatechange																		- Изменение readyState. Может не вызываться когда readyState получает значение 0, 1. Часто вызывается при sent()
		- readyState																		- Целочисленное значение, код состояниия http-запроса, имеет 5 значений (0, 1, 2, 3, 4), которым соответствуют константы XMLHttpRequest.UNSENT, OPENED, HEADERS_RECEIVED, LOADING, DONE. Расшифровка: Ме­тод open() еще не был вы­зван, был вы­зван, бы­ли по­лу­че­ны за­го­лов­ки , идет при­ем те­ла от­ве­та, при­ем от­ве­та за­вер­шен
		- status																				- Возращает код состояния HTTP в числовом виде (200, 400)
		- statusText																		- -//- в текстовом виде (OK, NotFound)
	- loadstart																				- событие вызывается 1 раз, после метода request.send() PS В хроме не смог запустить
	- load																					- возбуждается по завершению запроса
	- progress																				- в ходе загрузки ответа с сервера, обычно вызывается каждые 50 мс. PS не смог нормально использовать.
		- event.loaded																		- количесвто переданных байтов сервером
		- event.total																		- размер передаваймого файла в байтах (определяется из заголовка 'Content-Length' или 0 если не определен)
		- event.lengthComputable														- возращает true если размер возращаемого файла определен
	- timeout																				- вызывается когда превышено предельное время ответа сервера
	- abort()																				- завершить запрос
	- abort																					- вызывается если выполнение запроса было прервано методом abort()
	- timeout																				- событие вызванное превышением времени ожидания установленного пользователем свойства xhr.timeout = x мс.
		- timeout																			- свойство устанавливает время таймаута ожидания от сервера в милисекундах
	- error																					- если в результате запроса ошибка (например слишком большое количество переадресаций)
	- loadend																				- возбуждается 1 раз после события «load», «abort», «timeout» и «error»
	- свойства получения ответа -
	- getResponseHeader()																- Получает зоголовки ответа. Если указать аргументом заголовок Set-Cookie или Set-Cookie2 (Cookies) вернет null, так как исключается
	- getAllResponseHeaders().															- Получает зоголовки ответа. Cookies не попадает в окончательный список, так как исключается
	- request.overrideMimeType('text/plain; charset=UTF-8')					- Переопределить mime-заголовок, вызвать перед send()
	- request.responseText 																- Получение ответа, если ответ в виде текста (application/json, application/Ja­va­Script, text/Ja­va­Script)
	- request.responseXML(если документ)											- Получение ответа, если ответ в виде объекта document
	
	- Запрос в формате html-форм application/x-www-form-urlencoded-
	Для того что-бы отправить данные на сервер в формате формы необходимо создать строку в формате param1=value1&param2=value и отправить MIME-типом application/x-www-form-urlencoded, в строке перед отправкой необходимо заменить пробелы '%20' на '+' и обработать функцией encodeURIComponent()

	- Запрос в формате json -
	request.setRequestHeader("Content-Type", "application/json");
   request.send(JSON.stringify(data));

   - Отправка в xml -
   Для отправки достаточно, методу send, передать объект-xml document. Content-tupe - устанавливать не нужно.

   - Отправка file -
   Если при отправке файла из html формы (input type=file), который хранится в свойстве files элемента формы, не задан заголовок 'Content-Type', тогда заголовок определится типом Blod. File является наследником типа Blod. Так-же с помощью типа Blod можно передавать двоичные данные.

   - отправка multipart/form-data -
   multipart позволяет отправлять такие данные как (File, Blod, строки). В нем определен прикладной интерфейс FormData. С помощью конструктора FormData создается объект, затем методом объекта append() добавляются данные. При передаче методу send() объекта formData, заголовок определяется автоматически.
   PS Отправка отдельного файла не увенчалась успехом.

   - события выгрузки HTTP-запроса -
   свойство XMLHttpRequest.upload не имеет события readystatechange, но имеет следующие события и свойства:
   - progress																				- аналагичен загрузке
   - load																					- -//-

   - заголовок CORS -
   Если заголовок CORS орпеделен в интерпретаторе, то можо выполнять междоменные ajax запросы (в обход политики общего происхождения). Некоторые особенности: при передаче логина и пароля из формы, междоменным запросом, данные не передадутся. Любые данные об идентификации, так-же не передаются (Cookies, http-лексемы). PS В у меня хроме запрщено.
   - (new XMLHttpRequest()).withCredentials										- проверка поддержки заголовков CORS

   - JSONP -
   Позволяет получать данные в формате json, вызывая из созданного объекта script. В атрибут src передается url + '?jsonp=func', где func - функция js, которая обертывает ответ.

   - Comet на основе Server-Sent Events -
   - new EventSource('server_url.php')												- создание объекта для управления Server-Sent Events
   - eventSource.onmessage																- слушатель события message
   - event.type																			- определяет тип сообщения (как правило 'message', но бывают и другие)
   - event.data																			- содержит сообщение отправленное сервером

19 JQuery
	Библиотека jquery добавляет две глобальных переменных jQuery() и $
	JQuery перегружена и может быть вызванна в 4 вариантах:
		- 1- передача css селектора													- возращает множество объектов отвечающих селектору
		- 2- передача $() элемента, объ. Element, Window						- обертывает объект, объектом JQuery
		- 3- передача строки html														- создает html element, вторым аргументом может быть передан объект с аттрибутами создаваемого элемента.
		- 4- $(function(){})																- аналогичен window.onLoad = function(){}
	- jQuery.noConflict()																- убрать $ из глобального пространства имен. При этом можно воспользоваться jQuery(function($){}) -> $ ссылается на функцию jQuery.
	- Терминология jQuery -
		- Функция jQuery -																- $ или jQuery. Эта функция создает объекты jQuery, регистрирует обработчики загрузки DOM
		- Объект jQuery - 																- объект возращаемый функцией jQuery. "Результат функции jQuery", "множество jQuery", "обернутый набор"
		- Выбранные элементы -															- объект jQuery, содержащий множество элементов соответствующих css селектору
		- функция бублиотеки jQuery -													- по сути статические методы jQuery. Например jQuery.noConflict.
		- метод jQuery -																	- вызываются для объектов, которые созданны функцией jQuery
	Объект jQuery является массивоподобным объектом, который содержит множество в зависимости от вызова. Вместо length, можно использовать size(), вместо индексов -метод get(). Можно вообще привести к массиву с помощью toArray().
	- jquery																					- свойство объекта jQuery, которое возвращает версию JQ
	- each()																					- метод jQuery, в ед. аргументе принимает callback(), который вызывается как метод элементов массива. В callback передаюся 2 аргумента, индекс и элемент. Если callback элемента вернет false, то each (итерации) закончатся. this - не является обернутым в jQuery
	- map()																					- метод jQuery, во многом похож на each(), вызывает callback(), для каждого элемента и если ответ не (null || undefined) тогда добавляет во временный массив, который возвращает как объект jQuery. Если в элемент возращает массив, то элементы массива будут по отдельности добавленны в формирующийся массив.
	- index()																				- метод объекта jQuery, возвращает индекс элемента в множестве.
	- is()																					- метод объекта jQuery, возращает true, если множество содержит хотя-бы 1 указанный css селектор.

	- методы чтенния и записи jq -
	Методы чтения возращают только значение первого элемента во множестве jq, тогда как для записи, применяется для всех элементов.
	- attr('at', [val])																	- Получение/запись атрибута at. атрибут может иметь имя как 'class', так и 'className'
	- css('param', [value])																- получение/запись css-стиля, возращает и вычисленные стили. Нельзя получить составные css-свойства такие как 'margin', 'padding', составные стили можно устанавливать. Также можно передавать набор свойств, для этого единственным аргументом нужно передать объект с ключами и значениями css.
	- addClass()																			- добавляет класс, если такого нет. $('p').addClass(function(n){return 'class' + n}); похож на $each()
	- removeClass()																		- удаляет класс, может работать как each()
	- toggleClass()																		- если класс присутствует, то удалить, иначе добавить, может работать как each()
	- hasClass()																			- проверяет наличие класса, может работать только с одним классом
	- val()																					- применяется для получения значения полей форм, $("input:radio[name=ship]:checked").val(), $("input:checkbox").val(["opt1", "opt2"]), $("input:text").val(function(){ return this.defaultValue; } - установить все текста в default
	- text()																					- (без аргументов) - возращает текст, без тегов всех элементов (включая потомков). При записи (с аргументом), перезаписывает содержимое всех элементов множества на значение аргумента.
	- html()																					- (без аргументов) - возращает все содержимое с тегами первого элемента множества. При записи, работает так-же как и text();

	- методы гиометрии элемента -
	- offset()																				- получает значение (top, left), относительно документа. При записи устанавливает style(top, left), при необходимости, устанавливает position. Если использовать запись как $each(), то вожно возращать объект return {left: valueL, top: valueT};
	- position																				- похож на offset, но позволяет только читать координаты. Координаты вычисляются относительно родителя offsetParent() (ближайший элемент предок, который позиционирует данный элемент)
	- width (height)																		- получают только для чтения чистую высоту (ширину), без рамок, отступов, полей. Могут применятся (в отличии от 2 следующих) к windiw и document. Работают для записи. При передачи числа для записи, интерпретируется в пиксели, можно передавать другие размеры в формате css строки. Аргументом можно передать функцию. При dox-sizing: border-box $(e).width(x).width - вернет, в общем услучае, значение отличающееся от x, т.к. при записи устанавливает просто width.
	- innerWidth (innerHeight)															- получает внутренний размер элемента (внутри рамки, только для чтения)
	- outerWidth (outerHeight)															- аналог предыдущего, только с отступами и рамкой. Если передать значение true, то вычислит и поля.
	- scrollTop(), scrollLeft()														- чтение/запись позиции полосы прокрутки элемента. Нельзя передавать функции.

	- data()																					- (чтение/запись) позволяет добовлять свойства со значениями, с которыми можно работать только js (не отображаются в html), если для чтения передать объект, то перезапишет все старые данные.
	- removeData()																			- удаляет данные по ключю, либо если без аргументов - удаляет все данные.

	- Изменение структуры документа -
	Все методы, в этом блоке могут получать аргумент, который должен быть вставленн в документ. Это может быть строка текста, html текст, объект jquery, элемент element, текстовый узел Node. Вставка может быть выполнена внутрь, перед, после и вместо (в звисимости от выбранного метода). Если в качестве вставляемого содержимого используется элемент из документа, то он перемещается. Если вставка сразу в несколько мест, тогда копирование необходимое количество раз. Все методы возращаеют объект jquery. Каждый из пяти методов может принимать функцию. this будет указывать на текущий элемент, первый аргумент будет индекс элемента в списке значений. 2 аргумент (кроме методов before, after) будет указывать на содержание. Все 5 методов имеют "перевертыши" $('h1').before('hr') -> $('hr').insertBefore('h1')
	- $('#log').append('<br>' + message)											- добавить содержимое в конце элемента #log						- appendTo
	- $('h1').prepend('§')																- добавить знак параграфа в начало каждого заголовка h1		- prependTo
	- $('h1').before('hr')																- вставить линию перед каждым элементом h1						- insertBefore
	- $('h1').after('hr')																- добавить линию после каждого элемента h1						- insertAfter
	- $('hr').replaceWith('<br>')														- заменить все горизонтальные линии переводом строки			- replaceAll
		$('h2').each(function(){var h2 = $(this); h2.replaceWith('<h1>' + h2.html() + '</h1>')});
		$('h1').map(function(){ return this.firstChild; }).before('§');
	Между простыми методами и перевертышами есть несколько отличий:
	1) нормальные методы интерпретируют передоваемую строку как html-строку, перевертыши - как селектор (аргумент), можно передавать element, node, объект jquery.
	2) методы "перевертыши" не принимают функции
	3) нормальные методы возращают объект jquery, вызываемого элемента. Методы "перевертыши" вызываются относительно содержимого, но возращают jquery-объект содержимого после вставки.

	- clone([boolean])																	- создает копию объекта со всеми наследниками. Актуално если нужна вставить 1 элемент(копию). По умолчанию не копирует обработчики и данные (data), для того что-бы скопировать эти данные необходимо аргументом передать true.
	- wrap()																					- $('h1').wrap(document.createElement('i'))	->		<i><h1>...</h1></i>
	- wrapInner()																			- $('h1').innerWrap('<i>')							->		<h1><i>...</i></h1>
	- wrapAll()																				- $('p').wrapAll('<div class="wrapper">')		->		обернет все <p> в div class="wrapper"
		- всем трем методам wrap, аргументом можно передавать элемент или html-строку. Html-строка может содержать и вложенные элементы (на верхнем уровне должен быть 1 элемент), можно передать функцию аргументом (будет вызываться для каждого элемента)

	- удаление элементов -
	- empty()																				- удаляет все дочерние узлы, в т.ч. и textNode
	- remove()																				- удаляет все элементы из объекта jQuery. Если передать аргумент, то он будет интерпретирован как селекор, и удалятся только те элементы, которые соответствуют селектору. Если необходимо удалить элементы из множества объекта jQuery, но не из документа, следует применить filter(). Метод так-же удаляет все обработчики и другие (data)
	- detach()																				- подобен remove(), но не удаляет обработчики и (data)
	- unwrap()																				- удаляет родительский элемент каждого выбранного элемента. Не принимает необязательный атрибут - селектор
	
	- события jquery -
	События jquery походи на addEventListener, они кроссбраузерны и обладают расширенным функционалом. Так-же событие вешается сразу на все элементы объекта jQuery.
	jQuery имеет слудующие обработчики:	blur, focusin, mousedown, mouseup, change, focusout, mouseenter, resize, click, keydown, mouseleave, scroll, dblclick, keypress, mousemove, select, error, keyup, mouseout, submit, focus, load, mouseover, unload. События jQuery создают объект event даже в браузерах IE < 9. Если функция обработчик вернет false, то действие по умалчанию элемента выполнено не будет. Значение возращаемое обработчиком события (отличное от undefined) сохраняется в свойстве event.result.
	Некоторые особенности:
	- focus и blur																			- не всплывают в отличии от focusin, focusout.
	- mouseover, mouseout																- наоборот всплывают. Mouseenter, mouseleave - не всплывают.
	- resize и unload																		- вызываются и работают только с $(window).
	- load																					- можно применять к window, img, iframe. $(window).load() можно применить в сокращенной форме -> $().
	- error																					- можно применять к img для неудач загрузки img. Не должен применятся для установки свойства onerror window.
	- hover																					- работает как 2 события mouseenter, mouseleave
	- toggle																					- снят с поддержки. Вешал на click несколько обработчиков, которые выполнялись по очереди.
	При создании объекта $('<img>'), во втором аргументе можно передать аттрибуты и если в нем есть свойство с таким же именем как событие, то значение этого свойства будет обработчиком. Пример $('<img>', {className: 'img1080', click: function(){$(this).css('...', '...')}})
	Объект event jQuery имеет следующие св-ва:
		altKey, ctrlKey, newValue, screenX, attrChange, currentTarget, offsetX, screenY, attrName, detail, offsetY, shiftKey, bubbles, eventPhase, originalTarget, srcElement, button, fromElement, pageX, target, cancelable, keyCode, pageY, toElement, charCode, layerX, prevValue, view, clientX, layerY, relatedNode, wheelDelta, clientY, metaKey, relatedTarget, which
	Объект event имеет следующие методы:
		preventDefault(), isDefaultPrevented(), stopPropagation(), isPropagationStopped(), stopImmediatePropagation(), isImmediatePropagationStopped()
	
	- target																					- Ссылается на элемент вызвавший событие. Если target ссылается на textNode, то в jquery textNode обертывается элементом родителем.
	- currentTarget																		- элемент в котором зарегистрировано событие. Должно совпадать с this
	- relatedTarget																		- ссыл­ка на дру­гой эле­мент, во­вле­чен­ный в со­бы­тия пе­ре­хо­да, та­кие как «mouseover» и «mouseout»
	- timeStamp																				- устанавливает время возникновения события (в миллесекундах). (new Date()).getTime();
	- which																					- нажатая кнопка мыши (клавиатуры) события (мыши, клавиатуры)
	- handler																				- ссыл­ка на те­ку­щую функ­цию об­ра­бот­чи­ка со­бы­тия.
	- result																					- воз­вра­щае­мое зна­че­ние пре­ды­ду­ще­го об­ра­бот­чи­ка это­го со­бы­тия. Об­ра­бот­чи­ки, не воз­вра­щаю­щие ни­че­го, не учи­ты­ва­ют­ся.
	- originalEvent																		- ссыл­ка на стан­дарт­ный объ­ект Event, соз­дан­ный бро­узе­ром.
	- bind()																					- позволяет передавать несколько обработчиков, передавать данные и функцию. $('p').bind('click mouseover', 100500, f). 100500 будет доступно как event.data. Возможен использование пространства имен $('a').bind('mouseover.myMod', f). Возможно передавать объект из свойств-событий и значений-обработчиков, $('a').bind({mouseenter:f, mouseleave:g});
	- one()																					- аналогичен bind(), но вызывается только один раз
	ВСе события jQuery не могут повлиять на всплытие и являются синхронными
	- unbind()																				- удалить обработчики события, зарегистрированные с помощью bind() или $().event(func... $(*).unbind() - удалит все обработчики, $('a').unbind('click mouseover') - удалит обработчики в ссылках. Так-же работает с пространством имен $('a').unbind('click.room') .unbind(.myMod) - удалить все из пространства
	- trigger()																				- запускает обработчик передаваемого типа. вместо $('#form').submit() можно вызвать $('#form').trigger('submit'). Он позволяет указывать пространство имен. $('button').trigger('click.ns1') -> использовать click из пространства имен ns1, $('button').trigger('click!') -> вызвать click() для buttons не связанные с пространством имем. Можно передать объект event из внешенего события. Так-же можно передавать дополнительные свойства вторым аргументом.
	- $.event.trigger('cllick')														- вызов широковещательного события, который не работает
	- triggerHandler()																	- запуск как trigger, но без выполнения действия по умолчанию и без всплытия
	В $('#id').event(func..{...}) можно отключить событие по умолчанию e.preventDefault = true;
	- delegate()																			- если элементы созданны днамически, то delegate вешает события и на них $(document).delegate('a', 'click', f), подобно bind() может содержать еще один аттрибут со значением data, который необходимо передавать 3м значением, а функцию четвертым.	
	- undelegate()																			- удаляет все динамические обработчики. $('document').undelegate(a, [mouseover], [f]) [для события][[для обработчика]], можно вызвать без аргументов в таком случае будут удалены все динамические обработчики
	- live()																					- снят с поддержки
	- die																						- тоже

	- анимация jQuery -
	Длинна анимации задается временем в милисекундах или в виде строки 'slow' - 600мс, fast - 200мс. По умолчанию - 400мс. Можно изменить значения: jQuery.fx.speeds['medium-fast'] = 300, jQuery.fx.speeds['medium-slow'] = 500. Некоторые анимационные эфекты, без значения в аргументе выполняются немедленно. Эффекты выполняются асинхронно. Кроме аргумента время, вторым можно передать функцию, this которой будет указывать на элемент(анимации), которая вызавится после завершения анимации. Анимации выполняются друг за другом по очереди (синхронно), но это поведение можно изменить.
	- $(el).fadeIn({
		duration: 'fast',
		complete: function()...
	});																						- альтернативный вариант
	- jQuery.fx.off = true;																- установить время всех анимаций 0
	- методы -
	- $(el).fadeIn(time, [function])													- display: none -> block; С плавным увеличением opacity;
	- $(el).fadeOut()																		- противополежен предыдущему
	- fadeTo(arg1, arg2)																	- arg1 обязательный время, arg2 - обязательный, указывает конечный opacity
	- hide()																					- сворачивает элемент вверх с плавным добавлением прозрачности. Если не установить время, выполнится немедленно
	- show()																					- выполняет обратное действие
	- toggle()																				- hide() + show() в зависимости от состояния
	- slideUp, slideDown, slideToggle												- тоже что и hide, show, toggle, но без прозрачности
	- animate(arg1, [time, duration, complete], [arg2])						- arg1 обязательный- объект определяющий изменяемые аттрибуты css-свойств. arg2- func или obj с params эфектов, возможно применения аргументов (не в объекте duration, easing, comlete)
	Если используются не пиксели, тогда использовать в таком виде:
	$('p').animate({
		'margin-left' : '+=.5in',		<- margin-left - из-за дефиса следует использовать кавычки. Можно использоать marginLeft
		opacity: '-=.1'
	});
	$('img').animate({
		width: hide;
	})																							- при использовании hide - значение width сохранится исходное, но в коннце вызавится hide(), который display=none, есть значения show и toggle.
	- параметры передаваемые в анимацию во втором аргументе:
	- duration																				- длительность анимации
	- comlete																				- определяет функцию, которая вызовится по завршении анимации
	- step																					- определяет функцию, которая вызывается на каждом шаге анимации
	- queue																					- определяет будет ли данная анимация в очереди. queue = false -> выполнение незамедлительно
	Существуют функции переходов (линейные, синусоидные), возможно определить свои функции перехода jQuery.easing["squareroot"] = Math.sqrt.
	- easing																					- определяет функцию перехода, по умолчанию - easing: swing. Есть еще linear.
	Для того что-бы определить разные функции перехода, для разных css-свойств есть 2 варианта:
	1)	$("img").animate({ width:"hide", height:"hide", opacity:"hide" }, { specialEasing: { width: "linear", height: "linear" }});
	2)	$("img").animate({ width: ["hide", "linear"], height: ["hide", "linear"], opacity:"hide" });
	- stop([arg1], [arg2])																- останавливает анимацию выбранного элемента. arg1 = true - сбрасывает очередь аримаций (false - по умолчанию), arg2 - указывает, должно ли значение принять конечное значение (если true), или отсавить текущее (false - по умолчанию).
	- delay(arg1, [arg2])																- задержка, arg1- (милисекунды|строка), arg2- имя очереди. Возможно $("img").fadeTo(100,0.5).delay(200).slideUp()
	- queue()																				- добавляет новую функцию анимации в очередь. Если передать массив функций, заменит очередь на массив. Если вызвать без аргументов - вернет очередь. next() вызывает следующую функцию в очереди или $(this).dequeue. Пример: $('#blinker').click(function(){$(this).animate({width: 100}, 1000).queue(function(next){$(this).css('borderWidth', '20'); next();}).animate({height: 50}, {queue: false, quduration: 1000} ).animate({width: 600}, 1000);});
	- clearQueue()																			- очищает очередь

	- AJAX jQuery -
	Все функции ajax jQuery вызывают callbacks, во втором аргументе передается строка с одним из значений:
		- succes																				- удачный запрос
		- notmodified																		- http-ответ 304, запрос вернул такой-же объект как и предыдущий запрос
		- error																				- запрос завершился ошибкой, код ошибки можно узнать из объекта XMLHttpRequest, который передается callback
		- timeout																			- По умол­ча­нию Ajax в jQuery не име­ют ог­ра­ни­че­ний по вре­ме­ни. Код мо­жет быть по­лу­чен, ес­ли был ус­та­нов­лен timeout
		- parserror																			- запрос завершен успешно, но jQuery не смог разобрать ответ (например xml или AJAX сформирован с ошибками)
	- $(elem).load('address')															- Запрос в address и запись его в elem (если было значение, перепишет). $(el).load('link #id')- запишет #id в el
		функция load позволяет получать фрагменты html $('#temp').load("weather_report.html #temperature"); После обязательного аргумента url, фунцкия принимает 2 необязательных, 1- данные для отправки (если стока, то метод отправится методом GET. Если передать объект- то преобразуется в строку и передастся методом POST), 2- функция, которая вызовится после завершения запроса.
	- $.getScript(), $.post(), $.get()												- выполняются асинхронно, результат получается с помощью callbacks
	- $.getScript(url)																	- асинхронно загружает с url js и выполняет в глобальной области видимости. Выполнятся могут и сторонние скрипты, callback вызывается только в случае удачного вызова.
	- $.getJSON('data.jason', function(data){ ... })							- подобна getScript, проверяет валидность json и если валиден то выполняется callback, вторым атрибутом допускается передача данных.
	- $(form).serialize()																- переводит значения формы в вид par1=val1&par2=val2
	- $.param(object)																		- переводит объект или массив в рпигодный для передачи по url вид {'arr': [1, 2]} -> arr[]=1&arr[]=2
	- $.post(), $.get()																	- позволяет отправить/получить данные. Аргументы теже что и $.getJSON(): url, [data], callback. 4й необязательный аргумент позволяет передать тип запрашиваемых данных 'text', 'script', 'json'.
	- типы поддерживаемые в jQuery ($post, $get, $ajax):						- text, html, xml, script, json, jsonp. Если при вызове $get, $post, $ajax не определен тип, то будет выполнена проверка на тип xml, json, js. Иначе текст

	- $.ajax()																				- функция, которую вызывают все сотальные ajax функции. Принимает один аргумент - объект с параметрами.
		$.ajax({
			type: 'GET',																	- тип запроса
			url: url,																		- url
			data: null,																		- не добавлять дополнительные данные в сценарий
			dataType: 'script',															- выполнить ответ как сценарий
			success: callback																- вызвать по завершении
		})
		Возможно определить значения по умолчанию для любых из параметров:
		$.ajaxSetup({
			timeout: 2000,																	- прерывание запроса через 2 сек					
			cache: false																	- игнорировать кешь браузера, добавляя время в url
		})
		часто используемые параметры:
			- type																			- метод отправки 'Get', 'Post', 'Delete', 'PUT'
			- url																				- при get и cache=true, автоматически добавляет параметр (время) в url
			- data																			- может быть строкой или объектом. При GET- добавляет в конец url. Объекты обычно преобр. в строки. но есть искл.
			- dataType																		- тип ожидаемых данных
			- contentType																	- определяет Content-type, default-'application/x-www-form-urlencoded'. Если отправить POST, то нужно определить
			- timeOut																		- время ожиания ответа. При превышении timeout- вызовется error() с кодом (timeout). default- 0
			- cache																			- при установке этого параметра в false добавит параметр _= со значением времени в милисекундах
			- success																		- callback при удачном вызове success: function(result){ console.log(result); }
			- ifModified																	- если = true, то при возрате такого-же значения (Last-modified) значение запроса будет- undefined, default-false
			- global																			- если установить в false, то запретит все события ajax
		параметры функции обратного вызова
			- context																		- определяет объект контекст вызова для callback, default- AJAX object.
			- beforeSend																	- функция перед отправкой запроса. 1 аргументом передается объект XMLHttpRequest, 2- объект запроса. Дает возможность установить собственные HTTP-заголовки в объекте XMLHttpRrequest. Если вернет false, ajax будет остановлен. script и jsonp не используют XHR
			- success																		- функция в случае успеха. 1 аргумент- данные ответа сервера, 2- код $ответа 3- объект XHR
			- error																			- функция в случае ошибки. 1 арг- объект XHR, 2- код состояния. Для типа script ошибки не будет.
			- complete																		- функция выполняемая по завершению запроса. Вызывается после error, success. 1 арг- XHR, 2- код состояния.
		редко используемые параметры
			- async																			- если установать false, то будет выполнен синхронно
			- dataFilter																	- определяет функцию фильтрации или предварительной обработки данных, возращаемых сервером. В 1 арг будут передаваться необработанные данные, 2 арг- значение параметра dataType. Фнкция вызывается до розбора json или перед выполнением сценария.
			- jsonp																			- если url не содержит 'jsonp=?' то вставка произойдет с помощью этого параметра
			- jsonpCallback																- будет как-то переименовывать 'jsonp=?' в url, на указанное в параметре
			- processData																	- Ко­гда data- объ­ект (или объ­ект пе­ре­да­ет­ся во 2 ар­гу­мен­те функ­ции jQuery.get() и род­ст­вен­ным ей функ­ци­ям), jQuery обыч­но пре­об­ра­зу­ет объ­ект фор­ма­те «appli­ca­tion/x-www-form-urlencoded». Ес­ли нужно пре­дот­вра­тить это пре­об­ра­зо­ва­ние (на­при­мер, что­бы пе­ре­дать объ­ект Document в те­ле POST-за­про­са), при­свой­те это­му па­ра­мет­ру зна­че­ние false.
			- scriptCharset																- устанавливает charset для script и jsonp
			- traditional																	- при true установит старый формат «application/x-www-form-urlencoded» преобразовнаия строки
			- username, password															- ес­ли для вы­пол­не­ния за­про­са не­об­хо­ди­мо вы­пол­нить ау­тен­ти­фи­ка­цию поль­зо­ва­те­ля, ука­жи­те имя поль­зо­ва­те­ля и па­роль в этих двух па­ра­мет­рах.
			- xhr																				- оп­ре­де­ля­ет фаб­рич­ную функ­цию, соз­даю­щую объ­ект XMLHttp­Request
	- события в AJAX
		функция обратного вызова				Тип события							Метод регистрации обработчика
			beforeSend									"ajaxSend"							ajaxSend()
			success										"ajaxSuccess"						ajaxSuccess()							bind- пример
			error											"ajaxError"							ajaxError()								$("#loading_animation").bind({
			complete										"ajaxComplete"						ajaxComplete()								ajaxStart: function() { $(this).show(); },
															"ajaxStart"							ajaxStart()									 ajaxStop: function() { $(this).hide(); }
															"ajaxStop"							ajaxStop()								});
	- вспомогательные функции -
	- $.browser																				- объект со свойствами броузера
	- $.contains(arg1, arg2)															- если arg1 содержит arg2 (элементы DOM), то вернет true
	- $.each()																				- в отличие от метода, может работать с массивами и объектами(метод тоже может). arg1- массив(объект) arg2-func
	- $.extend()																			- капирует свойства в arg1 из arg2 [arg3...argN], если передать 1 аргумент, свойства будут скопированы в объект $, возращаемое значение- объект в который копировались свойства. Если 1 аргументом передать true- будет выполнено глубокое копирование. var otpions=$.extend({},default_opt,user_opt)
	- $.globalEval()																		- выполняет строку js-кода в глобальной области видимости. (реально созздает временно тег скрипт и там запускает)
	- $.grep()																				- похожа на filter. arg1- массив, arg2- функция предикат, arg3- если true- инвертирует ответы предиката
	- $.inArray()																			- схожа с indexOf. arg1- искомый элемент, arg2- массив. Возращает индекс первого совпадания или -1
	- $.isArray()																			- true, если arg == array
	- $.isEmptyObject()																	- true, если arg не имеет перечислимых свойств
	- $.isFunction()																		- true, если функция. в IE <= 8 alert() и Element.attachEvent()- вернут false
	- $.isPlainObject()																	- true, ес­ли ар­гу­мент яв­ля­ет­ся «про­стым» объ­ек­том, а не эк­зем­п­ля­ром спе­циа­ли­зи­ро­ван­но­го ти­па или клас­са объ­ек­тов.
	- $.makeArray()																		- возращает массив созданный из массивоподобного объекта переданноый через arg1. Если объект не массивоподобный, то он будет единственным элементом нового массива.
	- $.map()																				- похож на map, но отличается, если func вернет null (или массив), то будет добавленно (каждый элемент по отдель)
	- $.merge()																				- аргументы- 2 массива (массивопод. obj), + значения из arg2 в arg1. return arg1. var clone=$.merge([], ariginal)
	- $.getJSON()																			- запрашивает JSON у url методом GET
	- $.parseJSON()																		- разбивает строку в формате JSON и возращает результат. Если работает стандартная функц. то вызывает ее. В случае ошибки выбрасывает exception
	- $.proxy()																				- напоминает bind, но не выполняет частичное применение объектов. arg1- func, arg2- obj. func вызывается в контексте obj(как метод указанного объекта). Можно вызвать arg1- obj, arg2- func.
	- $.support()																			- возращает объект с свойствами, которые являются логическими значениями поддержки возможнностей броузера.
	- $.trim()																				- аналог trim.

	- Селекторы jQuery -
	Фильтры применяются слева направо $('p:nth-child(3n+1):contains(JavaScript):not(:has(a))) - получить 1й или каждый третий обзац с текстом 'JavaScript', не содерж <a> Обычно фильтр эффективнее работает, если ему предшествует имя тега, за исключением id
	- Фильтры селекторов -
	- #id																						- id
	- .class																					- class
	- [attr]																					- проверка наличия аттрибута
	- [attr=value]																			- проверка аттр и значения
	- [attr!=value]																		- проверка аттр на неравенство
	- [attr^=value]																		- аттрибут начинается с value
	- [attr$=value]																		- аттрибут заканчивается значением
	- [attr*=value]																		- аттрибут содержит value
	- [attr`=value]																		- аттрибут содержит отдельное слово val		div.qwe = div[class`=qwe]
	- [attr|=value]																		- аттрибут начинается с value, за которым может следовать тере (любые другие символы (фигатень))
	- :animated																				- в настоящее время применяются анимационные эффекты
	- :button																				- <button>, <input type="button">
	- :checkbox																				- <input type='checkbox'>, эфективнее с тегом input:checkbox
	- :checked																				- соответствует выбранным элементам
	- :contains(text)																		- проверяет соответсвие тексту (любое вхождение)
	- :disabled																				- со­от­вет­ст­ву­ет эле­мен­там в за­пре­щенном состоянии
	- :enabled																				- соответствует разрешенным элементам
	- :empty																					- соответствует элементам, не имеющих потомков (в т. ч. текстовых)
	- :parent																				- элементы имеющие потомков. (расширение jQuery)
	- :eq(n)																					- соответствует только n-ному элементу в списке совпадений. (расширение jQuery)
	- :nth(n)																				- синоним предыдущего
	- :even																					- только элементы с четным индексом. (расширение jQuery)
	- :odd																					- только элементы с нечетным индексом. (расширение jQuery)
	- :file																					- <input type="file">. (расширение jQuery)
	- :first																					- первый элемент в списке. (расширение jQuery)
	- :last																					- полседний элемент. (расширение jQuery)
	- :first-child																			- первые дочерние элементы, своих родителей
	- :last-child																			- последние дочерние элементы, родителей
	- :gt(n)																					- выбирает из сформированного списка элементы с индексом больше n
	- :lt(n)																					- элементы списка с индексами от 0 до n. (расширение jQuery)
	- :has(sel)																				- выбор элементов имеющих потомков с селектором sel
	- :header																				- h1, h2, ..., h6. (расширение jQuery)
	- :hidden																				- элементы у которых offsetWidth и offsetHeight = 0
	- :visible																				- противоположен hidden
	- :image																					- <input type="image">, но не <img>. (расширение jQuery)
	- :input																					- соответствует <input>, <textarea>, <select>, <button>. (расширение jQuery)
	- :not(sel)																				- все селлекторы крому sel
	- :nth-child(n)																		- выбор n-ного дочернего элемента. n- может быть числом, словом(even, odd), формулой(kN + x). Индексы с еденицы(в отличии от остальных функций)
	- :only-child																			- элементы, которые являются еднственными доченими для родителей
	- :password																				- <input type="password">. (расширение jQuery)
	- :radio																					- <input type="radio">. (расширение jQuery)
	- :reset																					- <input type="reset">. (расширение jQuery)
	- :selected																				- <input type="select">, которые были выбранны. (расширение jQuery)
	- :submit																				- <input type="submit">, <button type="submit">. (расширение jQuery)
	- :text																					- <input type="text">. (расширение jQuery)

	- комбинирование селекторов -
	- $('p a')																				- все <a>, которые наследники <p>
	- $('ol > li')																			- все <li>, которые дочерние  элементы <ol>
	- $('#id + p')																			- выберет элемент <p>, если он сразу следует за #id, textNode и comments не учитываются
	- $('#one ~ p')																		- все элементы <p> братские к #one, которые следуют после #one
	- $('p, a')																				- все элементы <p> и <a>

	- методы выбора -
	Возращает объект $ в отличие от обращения как элементу массива
	- first()																				- возращает первый элемент из списка выбора (объекта $)
	- last()																					- последний элемент
	- eq(n)																					- возращает n-ный элемент, n может быть отрицательным- в этом случае отсчет с конца
	- slice()																				- аналогичен array.slice, только применяется для $()
	- filter()	(пересечение)															- может вызываться 3 различными способами
		- arg- селектор																	- вернет только те элементы из множества $(), которые соответствуют селектору arg
		- arg- объект $ (множество)													- вернет пересечение множеств элементов
		- arg- функция предикат															- привенит функцию предикат к каждому элементу множества и если вернет true, то добавит в новое множество
	- not()		(разность)																- противоположен filter
	- add()		(объединение)															- расширяет множество $. Можно передать аргументом элементы, селектору выборку $(''). Добавит элементы в множество, исключив повторы. Сортирует элементы так как следуют в документе.
	- addSelf()	(объединение)															- устарел
	- addBack() (объединение)															- вместо addSelf. добавляет текущиее множество к множеству выше в встеке убирая дубликаты. $('div').find('p').addBack()
	- has()																					- если передать селектор, то выберет все элементы соответствующие селектору и являющимися потомкамию. Если передать элемент, то вернет всех потомков элементов.
	- данные методы создают новый объект, не добавляя в старое множество, могут (кроме find) применятся без текста (селектора)
	- find()																					- ищет потомков из множества
	- children()																			- тоже самое, но можно без аргументов
	- contents()																			- не принимает аргумент (так как работает с document) тоже что и children, но работает с текстовыми узлами и для <iframe> возращает объект Document с содержимым
	- next(), prev()																		- возращают следующий (преддущий) элемент братский элемент из множества $. Может принимать arg- селектор
	- nextAll(), prevAll(), sublings													- возращает все следующие, предыдущие, все братские элементы, если передать селектор, то будут выбранны братья соответствующие селектору
	- nextUntil(), prevUntil()															- без аргумента как nextAll, prevAll. С аргументом выберет све элементы до(после) выбранного, до указанного в arg
	- parent()																				- возращает родителя выбранного элемента. Может принимать аргумент
	- parents()																				- возращает предков влоть до <html>, для каждого выбранного элемента, может принимать селектор
	- parentsUntil()																		- выбирает предков для каждого выбраного элемента, пока не будет встречен первый предок соответствующий указанному селектору.
	- closest()																				- принимает обязательный строковый аргумент и ищет ближайших предков (в соответствии с селектором)(если есть)

	- возврат к предыдущему выбору -
	При возвращении нового объекта из множества jQuery, новый объект хранит ссылку на предыдущий объект(множество) в "стеке ссылок"
	- end()																					- выталкивает предыдущий объект из стека. $("div").find("p").addClass("highlight").end().css("border", "solid black 1px");
	- pushStack()																			- заменяет множество на arg, ссылку на пред. множество заносит в стек, доступную для end(). divs.pushStack(spans)

	jQuery- можно дополнять своими функциями и методами: jQuery.fn.func = ...; добавит метод func, jQuery.func- добавит функцию. Так-же можно изменять продолжительность визуальных эффектов jQuery.fx.speeds, новые функции переходов jQuery.easing. Новые механизмы селекторов jQuery- jQuery.expr[':'].draggable = function(e){ return e.draggable === true; };

20 Сохранение данных на стороне клиента
	Существует несколько разновидностей хранилищ на стороне сервера:
	- Web Storage
	Определяют 2 свойства в объекте window: localStorage, sessionStorage, они ссылаются на объект Storage. localStorage и sessionStorage отличаются областью видимости и сроком хранения. На 2012 год, позволяли сохранять только строки.
		- localStorage																		- срок хранения localStorage не ограничен, но ограничен политикой общего происхождения (протокол, имя хоста, номер порта). В разных браузерах сохраняются разные localStorage. Доступен из разных окон браузера.
		- sessionStorage																	- ограничивается временем жизни открытого окна верхнего уровня или открытой вкладки (современные броузеры при запуске восстанавливают вкладки и объект sessionStorage). У разных окон, разные объекты sessionStorage. Если в 1 окне несколько разных документов в <iframe>, то у них один ssnStr
			- API -
		Лучше использовать API, так как он кроссбраузный и избавляет от путаниц
		- setItem(), getItem()															- сохранить(получить) значение значение. arg1- имя параметра, [arg2]- значение
		- removeItem(name)																- удалить значение name. можно удалить и с помощью delete, но неработает в IE <= 8
		- clear()																			- удалить все значения
		- key(n)																				- получить параметр с индексом n
			- События -
		При изменении хранимых данных в sessionStorage и localStorage во всех доступных к данным объектах window, создается событие storage. PS срабатывает в другом окне(не в том, которое вызывает событие). Событие имеет 5 свойств:
			- key																				- имя сохраняемого или удаляемого элемента. Если clear()- то key = null.
			- newValue																		- новое значение элемента или null, если удаление
			- oldValue																		- старое значение или null если создается новое
			- storageArea																	- будет хранить значение localStorage или sessionStorage объекта window
			- url																				- url (в виде строки), сценарий которого выполнил операцию с хранилищем
	- Cookies -
		По умолчанию время жизни = длинна сеанса(до закрытия броузера). Cookie хранится в браузере как и процедуры -> закрытие окна не влияет на жизнь cookie(в отличии от закрыт броузера). Для cookies есть ограничения: броузеры не обязаны хранить более 300 cookies, 20 cookies на 1 веб-сервер, 4kb- на 1 cookie
		- document.cookie																	- позволяет работать с cookie
		- navigator.cookieEnabled														- вернет true, усли включен режим сохранения cookies. Не стандартизированно -> альтернативная проверка
		- установка и чтение значение cookie -
		- max-age																			- аттрибут, указывает браузеру сохранять cookie после закрытия браузера в секундах
		Облать видимости может регулироваться аттрибутами path и domain. По умоляанию облать видимости ограничивается одним доменом и папкой (с подпапками) откуда было создано cookie
		- path('/')																			- '/'- корень сайта. Позволяет работать с cookie из всего сайта, '/catalog' - только из директории(поддиректорий)
		- domain('example.com')															- позволит использовать cookie с любого адреса заканчивающего на example.com. Нельзя указать другой домен
		Значение cookie не может содержать пробелов, точки з запятой, запятой. Для того что-бы сохранить значение необходимо применить encodeURIComponent(). для расшифровки decodeURIComp.
		- secure																				- логический атрибут, определяет передачу по защищенному https или по http
		- document.cookie = 'version=' + encodeURIComponent(val)				- создать свойство version со значением val для cookie
		document.cookie = 'x=' + 5 +'; max-age=' + (60 * 60 * 24 * 5) + '; secure=true'
																								- установить куку со значением x, на 5 дней, способ передачи https(но это не точно)
		- document.cookie = 'name=' + val + '; max-age=0';						- удаляют куку с помощью установления время жизни 0, тоже имя, путь, домен и любое значение.
	- IE User Data -
		В IE <= 5 доступно сохранение данных в нестандартном свойстве behavior (работает только в IE -> нецелесообразно конспектить)
	- Offline Web Application -
		Кэширование web-приложений для работы offline. При очистке кэша, "кэш" приложения не очищается, так как приложение как-бы хранится в "хранилище приложения". Сохранются все исходники (html, css, js, images и т.д.). Удаляются только когда приложение удалит себя или пользователь удалит. Используется localStorage. Для создания необходимо создать файл name.appcache в котором перечислить все ресурсы:
			CACHE MANIFEST
			CACHE:																			- кэшируемый раздел
				myapp.html
				myapp.js
			FALLBACK:																		- попытка загрузить videos. В случае неудачи, загрузить ис кэша offline_help.html										
				videos/ offline_help.html
			NETWORK:																			- разделы, которые никогда не должны кэшироваться, допускается использовать '*'- чтобы пытаться загрузеть не указанные в cache manifest
				cgi/
		Затем подлуючить в теге html
			<!DOCTYPE HTML>
			<html manifest="name.appcache">
		Сервер должен отправлять файл с MIME-типом "text/cache-manifest", если установить любой другой тип, то приложение не закешируется. Возможно будет необходимо настроить .htaccess
		Для удаления приложения из кэша необходимо что-бы на запрос файла манифеста, возращалось 404 "Not Found". Для обновления кэша, необходимо внести изменения в файл-манифест. Кэш загружается асинхронно и при запуске приложение в котором иземен манифест, загрузится старая версия приложения из кеша и обновятся кэши асинхронно (есть события обработки)
		- события кэша -
			- applicationCache.onupdateready											- вызов события изменения кэша.
				- location.reload()														- перезагрузка действующей страницы
			- window.applicationCache.onchecking									- вызывается при проверке файла объявления. Вызывается первым при загрузке страницы
			- window.applicationCache.onnoupdate									- генерируется если приложение уже имеется в кэше и файл манифест не изменен - window.applicationCache.ondownloading								- если приложение еще не загружено в кеш или обновился манифест. Начало загрузки кэшей
			- window.applicationCache.onprogress									- генерируется во время загрузки (обычно при загрузке каждого файла)
			- window.applicationCache.oncached										- при завершении первой загрузки в кэш
			- window.applicationCache.onupdateready								- при завершении обновления всех кэшируемых файлов приложения (в окне браузера все еще старая версия)
			- window.applicationCache.onerror										- при попытке проверки файла манифеста в режиме offline или приложение ссылается на несуществующий файл манифеста
			- window.applicationCache.onobsolete									- при отсутствии файла на который ссылается html-manifest, происходит удаление приложения из кеша
			Все обработчики событий могут возращать false, что-бы отменить действие по умолчанию(вывод сообщений браузером типа, которые ничего и так не выводят)
		- альтернативы событиям кэша applicationCache.status -
			- ApplicationCache.UNCACHED	(0)										- это приложение не имеет атрибута манифест, оно не кэшируется
			- ApplicationCache.IDLE			(1)										- файл объявления проверен и в кэше находится последняя версия
			- ApplicationCache.CHECKING	(2)										- браузер проверяет файл оюъявления
			- ApplicationCache.DOWNLOADING(3)										- броузер производит загрузку/сохранения кэша
			- ApplicationCache.UPDATEREADY(4)										- была загружена и установлена последняя версия приложения
			- ApplicationCache.OBSOLETE	(5)										- файл объявления отсутствует, происходит удаление
		- ApplicationCache.update()													- явно запускает процедуру проверки наличия последней версии
		- ApplicationCache.swapCache()												- дает команду удалить старую версию кэша (когда загружена новая, но пользователь не перезагрузил страницу) и использовать новый кеш (например для ajax). Страница при этом не перезагружается. При OBSOLETE, удалит сразу весь кэш. Если вызвать когда не OBSOLETE или UPDATEREADY -> exception
		- navigator.online																- возращает true если приложение online
		- window.online																	- событие при доступе приложения к режиму online
		- window.offline																	- событие потери online-соединения приложения
	- Базы данных для Web -
	- Прикладной интерфейс к файловой системе -

- 21 Работа с графикой и медиафайлами -
	- видео и аудио-потоки -
		За видео и аудио отвечают html5 элементы <video> <audio>
		- <source src="news.mp4" type="video/mp4"									- применяется для того что-бы установить разные источники видео (разные форматы)
		Если внутри элемента video, audio определить текст или другой элемент (не пренадлежащий к audio и video), он выведется при отсутствии поддержки элемента audio(video)
		Элементы audio и video полностью похожи, за исключением того что у video есть атрибуты width и height
		- controls																			- атрибут, если установлен появляются элементы управления. В js, для включения должно быть установленно в true
		- new Audio('chime.wav').play();												- создать объект <audio>  в js и воспроизвести. video не имеет такого конструктора в js
		- audio.canPlayType('audi/wav')												- вернет пустую строку если браузер не способен воспроизвести и maybe(возможн) или probably(вероятно)
		- audi.src = 'chime.wav';														- при присваивании источника src, начинается загрузка данных (не много). для того что-бы началась полная, необходимо установить в свойстве preload значение auto. Если во время загрузки изменить src, загрузка прервется. При добавлении элементов source, загрузка не начнется до play()
		- a.play()																			- воспроизвести аудио(видео)
		- a.pause()																			- пауза
		- a.currentTime																	- свойство, устанавливает время в секундах куда необходимо совершить переход
		- a.volume																			- уровень громкости от 0 до 1
		- a.playbackRate																	- скорость проигрования (1 - нормальное значение). Отрицательное значение- проигрывание назад
		- a.defaultPlaybackRate															- скорость проигрывания по умолчанию. При каждом вызове play(), устанавливает playbackRate
		- a.muted																			- логическое значение, отключает звук в ауди-видеопотоке
		- a.controls																		- добавить стандартные элементы управления
		- a.preload																			- указывает минимальный объем загруженных данных, перед возможностью запустить проигрывание. Возможно значение auto- в этом случае браузер сам определит минимальный объем. none- предварительная загрузка не требуется. metadata- загрузка продолжительности видео, битрейт, размер кадра.	
		- a.autoplay																		- при установке в true, начнет автоматическое воспроизведение, после загрузки необходимого объема данныхs
	- определение состояния элементов мультимедиа -
		Все только для чтения
		- a.paused																			- вернет true если на паузе
		- a.seeking																			- вернет true если идет переход к новой позиции проигрывания
		- a.ended																			- true если достиг конец проигрывания
		- a.initialTime																	- определяет начальное время проигрывания. Для клипов с фиксированной длинной обычно- 0. Для потоковых данных- самое раннее время в буфере, к которому можно вернуться.
		- a.duration																		- продолжительность проигрываемых данных. Если еще не загружен- NaN, если трансляция- Infinity
		- a.played																			- возвращает диапазон(ы) проигрываемых в данный момент данных.
		- a.buffered																		- возращает диапазон(ы) времени буферизированных данных.
		- a.seekable																		- возращает диапазон(ы) времени куда проигрыватель может совершить переход.
		Свойства played, buffered, seekable являются объектами TimeRanges. Каждый имеет свойства length, представляющий количество представляемых им диапазонов перехоодов. Методы start(), end()- возращающие начало и конец диапазона.
		- a.readyState																		- определяет состояние, как много данных было загруженно и готов ли элемент начать воспроизведение. Свойство имеет как числовое значение, так и константу:
			- 0 HAVE_NOTHING																- метаданные еще не загружены
			- 1 HAVE_METADATA																- метаданные были загружены, но мультемедийные данные еще не были загружны
			- 2 HAVE_CURRENT_DATA														- мультемедийные данные для currentTime были загружены, но недостаточно для воспроизведения
			- 3 HAVE_FUTURE_DATA															- данных хватает для воспроизведения, но не до самого конца
			- 4 HAVE_ENOUGH_DATA															- загружено данных до конца воспроизведения
		- a.networkState																	- определяет состояние загрузки из сети. Так-же имеет число и константу в значении
			- 0 NETWORK_EMPTY																- элемент еще не начал использовать сеть. Возможно еще не установлен src
			- 1 NETWORK_IDLE																- в настоящее время элемент не загружается из сети. Возможно он уже загружен или preload=none + не было play()
			- 2 NETWORK_LOADING															- идет загрузка из сети
			- 3 NETWORK_NO_SOURCE														- элемент не может найти источник данных для воспроизведения
		При отсутствии ошибок свойство error имеет значение null, иначе error.code имеет числовое значение ошибки	if (song.error.code == song.error.MEDIA_ERR_DECODE)
			- 1 MEDIA_ERR_ABORTED														- пользователь потребовал остановить загрузку медиа
			- 2 MEDIA_ERR_NETWORK														- данные имеют верный тип, но загрузке препятствует ошибка сети
			- 3 MEDIA_ERR_DECODE															- данные имеют верный тип, но есть ошибки декодирования
			- 4 MEDIA_ERR_SRC_NOT_SUPPORTED											- src имеет тип, который браузер не может воспроизвести
	- события элементов мультимеиа -
		события для <audio> <video> не имеют свойт для обработчиков событий, по этому обработчики можно зарегистрировать только с помощью addEventListener
		- loadstart																			- возбуждается когда элемент отправляет запрос на получение данных. nerworkState == NETWORK_LOADING
		- progress																			- загрузка продолжается. nerworkState == NETWORK_LOADING. возбуждается обычно 2-8 раз в секунду.
		- loadedmetadata																	- метаданные загружены и доступна инф-ция о продолжительности видео и размере кадра. readyState == HAVE_METADATA
		- loadeddata																		- данные для текущей позиции загружены, readyState == HAVE_CURRENT_DATA (еще не достаточно для воспроизведения)
		- canplay																			- загружен достаточный объем данных что-бы начать воспроизведение. readyState == HAVE_FUTURE_DATA
		- canplaythrough																	- загружен достаточный объем данных чтобы воспроизвести весь файл без дозогрузки. readyState == HAVE_ENOUGH_DATA
		- suspend																			- элемент загрузил достаточно данных и приостановил загрузку. networkState == NETWORK_IDLE
		- stalled																			- элемент пытается загрузить данные, но данные не поступают из сети. networkState == NETWORK_LOADING
		- play																				- был вызван play(), или автозапуск при атрибуте autoplay. Если достаточно данных, то playing, иначе waiting
		- waiting																			- воспроизв. не может быть начато или было приостановлено из-за нехватки данных в буфере. при достатке- playing
		- playing																			- начато воспроизведение клипа
		- timeupdate																		- изменилось значение свойства currentTime. Формируется около 4-60 раз в секунду
		- pause																				- был вызван метод pouse()
		- seeking																			- сценарий или user переходит к участку который еще не буферизирован и воспроизведение остановлено. seeking=true
		- seeked																				- seeking получает значение false
		- ended																				- воспроизведение достигло конца и отсановлено
		- durationchange																	- изменилось свойство duration
		- volumechange																		- изменилось свойство volume или muted
		- ratechange																		- изменилось свойство playbackRate или defaultPlaybackRaye
		- abort																				- элемент прекратил загрузку данных. Обычно по требованию пользователя. error.code = MEDIA_ERR_ABORTED
		- error																				- сетевая или другая ошибка кот. не дает загрузить данные. error.code = любое значение, кроме MEDIA_ERR_ABORTED
		- emptied																			- В ре­зуль­та­те со­бы­тия «error» или «abort» свой­ст­во networkState по­лу­чи­ло зна­че­ние NETWORK_EMPTY.
	- SVG -
		Объекты svg можно создавать 3мя способами: 1) через тег svg 2) <img> 3) background-image. Если нужно производить взаимодействия (анимации), то только первый вариант. svg-теги необходимо закрывать, так как svg использует XMl-синтаксис.
	- Canvas -
		большая часть прикладного интерфейса определена не в canvas, а в объекте контекста рисования, который только один для каждого canvas. атрибуты canvas (они же и свойства) width И height являются фундаментальными и изменение их приводит к очистке холста и свех графических атрибуттов. Количество пикселей на экране не всегда совпадают с количеством пикселей на поверхности для рисования (на устройствах с высоким разрешением разрешено отображать 1 CSS-пиксель может совпадать с несколькими аппаратными, тем самым увеличивая изображение). Для изменения маштаба необходимо щадать разные width и height в аттрибуте элемента и css-стилях (логические пиксели в аттрибутах)
		- var c = canvas.getContext('2d')											- вернет объект CanvasRenderingContext2D, контекст объекта рисования
		- canvas.getContext('webgl')													- вернет объект для работы с 3d
		- c.fillRect(x, y, dx, dy)														- залить прямоугольник
		- c.fill()																			- залить цветом
		Для того что-бы определть внутри ли одна фигура относительно второй используется правило ненулевого числа оборотов (как я понял, если луч светящий слева на право пересекает контур который рисовался по часовой стрелке то идекс плюсуется, если против часовой- отнимается. Если сумма ноль, тогда элемент считается наружным)
		- графические атрибуты объекта CanvasRenderingContext2D -
			- fillStyle																		- цвет, гра­ди­ент или шаб­лон, ис­поль­зуе­мый для за­лив­ки
			- font																			- оп­ре­де­ле­ние шриф­та в фор­ма­те CSS для ко­манд ри­со­ва­ния тек­ста
			- globalAlpha																	- уро­вень про­зрач­но­сти, на­зна­чае­мый для всех пик­се­лов при ри­со­ва­нии
			- globalCompositeOperation													- спо­соб объ­еди­не­ния но­вых пик­се­лов с су­ще­ст­вую­щи­ми
			- lineCap																		- фор­ма кон­цов ли­ний
			- lineJoin																		- фор­ма вер­шин
			- lineWidth																		- тол­щи­на ри­суе­мых ли­ний
			- miterLimit																	- мак­си­маль­ная дли­на ост­рых вер­шин
			- textAlign																		- вы­рав­ни­ва­ние тек­ста по го­ри­зон­та­ли
			- textBaseline																	- вы­рав­ни­ва­ние тек­ста по вер­ти­ка­ли
			- shadowBlur																	- чет­кость те­ней
			- shadowColor																	- цвет те­ней
			- shadowOffsetX																- го­ри­зон­таль­ное сме­ще­ние те­ней
			- shadowOffsetY																- вер­ти­каль­ное сме­ще­ние те­ней
			- strokeStyle																	- цвет, гра­ди­ент или шаб­лон, ис­поль­зуе­мый для ри­со­ва­ния ли­ний
		- save()																				- памещает (сохраняет) все значения аттрибутов CanvasRenderingContext2D в стек.
		- restore()																			- выталкивает значени аттрибутов из стека
		- некоторые функции преобразования системы координат -
			- translate(x, y)																- смещение
			- rotate(радианы)																- поворот в радианах
			- scale(x, y)																	- растяжение (сжатие) по x y
		- рисование линий -
			- c.beginPath();																- определить новый контур (не забывать при рисовании новых фигур т.к. при вызове stroke и fill- будут рисоватья и на предыдущих фигурах)
			- c.moveTo(x, y)																- перейти на начальную точку
			- c.lineTo(x, y)																- линия от предыдущей точки к (x, y)
			- c.stroke()																	- зарисовать определенный контур (c.lineTo - лишь определяет контур, но не ресует)
			- c.closePath()																- соединить 1 и конечную точку линии, имеет отдичие от замыкания линии с помощью c.lineTo при толстой линии
			- некоторые атрибуты рисования линий -
				- c.lineCap																	- стиль концов линии, имеет 3 значения: butt(по умолчанию), square(квадратные концы, выступают на половину толщины), round- (закругленные, выступающие на половину толщины)
				- c.lineJoin																- стиль соединения на вершине. Имеет 3 значения: 1- miter(default, внешние края сторон продолжаются), 2- round- закругление, 3- bevel- вершины обрезаются прямыми линиями
				- c.miterLimit																- обрезает угол если он miter и его длинны превышает коээфициент толщины? линии * meterLimit
		- рисование и заливка кривых -
			- arc(x,y,radius,startAngle,endAngle,anticlockwise)				- формирует контур окружности. Если начало окружности не первая точка контура, тогда она является 2 точкой отрезка с предыдущей точкай. От конечкай точка отрезка будет проделжена прямая (нпример если closePath());			
			- arcTo(x1,y1,x2,y2,radius)												- строит дугу радиусом radius, от отрезка x1y1-x2y2, к исходной точке (например предыдущему moveT() ), дуга обращена к первой точке.
			- c.bezierCurveTo(x1,y1,x2,y2,x3,y3)									- квадратичная кривая безье с двумя контрольными точками, от первой точки (moveTp например) до x3,y3
			- c.quadraticCurveTo(x1,y1,x2,y2)										- кривая безье с одной контрольной точкой
		- прямоугольники -
			- fillRect(x, y, width, height)											- выполняет заливку прямоугольника в соответствии с fillStyle
			- strokeRect(x, y, width, height)										- рисует контур прямоугольника в соответствии с strokeStyle
			- clearRect(x, y, width, height)											- подобен fillRect но заливает прозрачными черными пикселями (как на холсте по умолчанию)
			- rect(x, y, width, height)												- определяет контур прямоугольной области
		- цвет, прозрачность, градиент и шаблоон -
			К атрибутам strokeStyle, fillStyle можно присваивать объекты CanvasPattern и CanvasGradient что-бы рисование или заливка выполнялось с использованием повторяющегося изображения или линейного (радиального) градиента. Можно воспоьлзоваться свойством globalAlfa что-бы сделать полупрозрачным все, что будет рисоваться. Цвета можно задавать не только в формате '#rgb', но и 'color', 'rgb(n, n, n)', 'rgb(n%, n%, n%)', 'rgba(n,n,n,n)', hsl, hsla.
			- HSL																				- цвет, который определяется 3 числами	определяющими тон. Тон(Hue) - угол в цветовом круге. Насыщенность(Saturation)- определяется в %. Светосила(lightness)- тоже проценты.
			- c.fillStyle = c.createPattern($('#image'), 'repeat')			- выполнить заливку с помощью шаблона.
			- c.strokeStyle = -//-														- выполнить заливку толстого контура
				Первый аргумент createPattern должен быть либо <img>, <canvas>, <video>, Image (созданный с помощью конструктора). Во 2 аргументе могут быть repeat-x, repeat-y, no-repeat
			Для создания градиента необходимо c.fillStyle или c.strokeStyle присвоить объект CanvasGradient возращаемый методом(и) createLinearGradient() или createRadialGradient(). Создание происходит в несколько этапов:
			1) Создание объекта CanvasGradient. Для createLinearGradient() в args- координаты 2х точек. Для createRadialGradient() args- определяют центры и радиусы 2х окружностей (обычно первая находится полностью во второй). После того как CanvasGradient создан и определены области холста, необходимо определить цвета градиента с помощью addColorStop() объекта CanvasGradient
			- canvasGradient.addColorStop(0, 'transparent')						- для формирования цвета градиента необходимо вызвать минимум два раза addColorStop. arg1- определяет начало(если 0) конец(если 1, промежуточный может быть от 0 до 1) градиента.
		- рисование текста на холсте -
			- c.fillText('text', x, y)														- вывести текст, где левая нижняя часть текста начинается с координаты x, y.
			- c.strokeText('text', x, y)													- вывести контур текста.
				fillText и strokeText принимают 4 необязательный аргумент, который указывает максимальную ширину текста. Если текст шире, то он сжимается или уменьшается маштаб.
			- c.font = 'line'																	- установить параметры текста (как в css тег font) пример- "blold 14px sans-serif"
			- c.textAlign																		- свойство устанавливает выравнивание текста по x. Значения: start[default], left, center, end, right.
			- c.textBaseline																	- устанавливает по вертикали: (сверху в низ) top, hanging, middle, alphabetic[default], ideographic, bottom
			- c.dir (or direction)															- [не сработал] если присвоить 'rtl' (right to left), будет выводить текст справа на лево. inherit[default], ltr. Если установать rtl- то при textAlign='start' -> старт будет справа, аналагично с end.
			- c.measureText('text')															- возвращает объект со свойством width- где указана ширина текста 'text'.
		- отсечение -
			- c.clip()																			- после определения контуров и вызова clip, отрисовка буудет происходить только внутри определенных контуров. Увеличить область clip невозможно -> необхаодимо из стека доставать настойки c.restore();
		- тени -
			- c.shadowColor 																	- определяет цвет тени. Для рисования не могут использоваться шаблоны и градиенты.
			- c.shadowOffsetX (Y)															- определяет смещение тени
			- c.shadowBlur																		- определяет на сколько будет размыт край тени
		- изображение -
			- c.drowImage()																	- копирует в холст пиксели из выбранного изображения. Может вызываться с 3, 5, 9 аргументами. arg1- исходное изображение (может быть элемент img, объект Image, другой canvas, элемент video, если video или img еще не згружен- то ничего в canvas не передастся).
				- версия с 3мя аргументами													- arg2 и arg3- x, y- кординаты верхнего левого края изображения на холсте. При необходимости изображение будет маштабировано и повернуто.
				- версия с 5ю аргументами													- arg2, arg3 как прежде. arg4, arg5- width и height вставляемого изображения на холсте
				- версия с 9ю аргументами													- (arg2 - arg5) - область исходного изображение (arg6 - arg9) - куда будет скопировано на холсте
			- canvas.toDataURL()																- возращает изображение canvasa в png-формате в виде url-строки. В arg1 может передаваться другой mime-тип. Метод не работает с canvas, которые ссылаются на изображения, происхождение которых, отличается от документа
		- композиция -
			композиция - это как налаживаются новые пиксели на старые. По умолчанию новые (исходные) полупразрачные пиксели накладываются на старые (целевые) и старые видны через непрозр. Этот параметр можно изменить и он имеет 11 значений
			- c.globalCompositeOperation													- свойство которое устанавливает режим композиции. Может иметь 11 значений:
				- source-over																	- по умолчанию
				- source-atop																	- только та чать нового изображения сверху, которое попадает на старое + остаток старого
				- source-in																		- только та чать нового изображения сверху, которое попадает на старое. старое не отображается
				- source-out																	- та часть нового изображения, которое не попадает на старое. Старое не отображается
				- destination-over															- старое поверх нового
				- destination-atop															- та часть старого, кторое пересекается с новым сверху, отсальное старое срезано + остаток нового
				- destination-in																- только пересечение старого и нового (старое сверху)
				- destination-out																- старое - новое
				- copy																			- новое поверх старого
				- lighter																		- на пересечении смешивание цветов, остальное как есть
				- xor																				- на пересечении удаление цветов
				на момент написания книги 5 и 11 свойств не соответствовали стандарту в многих браузерах
		- манипулирование пикселями -
			- getImageData()																	- возращает объект ImageDate, представляющий массив пикселей rgba. Пиксели сохраняются в массиве слева направо и сверху вниз. С пикселями можно производить арифмитические операции, изменяя цвет пикселя.
			- createImageData()																- создает пустой объект ImageData
			- putImageData()																	- копирует пиксели из ImageData обратно в холст
		- определение попадания -
			- isPointInPath()																	- возращает true(flase), если точка находится внутри или на границе текущего! контура на холсте
21 Прикладные интерфейсы html5 -
	- геопозиционирование -
		Браузеры поддерживающие геопозиционирование определяют свойство navigator.geoposition, которое поддерживает три метода:
		- navigator.geolocation.getCurrentPosition()									- запрашивает текущее местонахождение пользователя
		- navigator.geolocation.watchPosition()										- запрашивает текущее местонахождение вызывается при изменении местоположения
		- navigator.geolocation.clearWatch()											- останавливает слежение за положением пользователя, аргументом нужно передать число возращаемое watchPos
		методы получения местоположения выполняются асинхронно и могут принимать три агрумента:
			1 callback, aргументом будет передан объект со значениями позиционирования:
				- pos.timestamp																- содержит значение времени локации. Можно использовать new Date(pos.timestamp).toLocalString()
				- pos.coords.latitude														- широта
				- pos.coords.longitude														- долгота
				- pos.coords.accuracy														- значение погрешности координат в метрах
				- pos.coords.altitude														- высота над уровнем моря
				- pos.coords.speed															- скорость м/сек
				- pos.coords.heading															- направление
			2 callback, которая будет выполнена в случае неудачи
			3 объект, свойства которого определяют- нужна ли высокая точность, насколько устаревшей может быть информация, предельное время ожидания определения местоположения:
				var options = {
					- enableHighAccuracy: false (default),								- для получения с высокой точностью (например с GPS), установить в true. При этом может вырасти расход энерг
					- maximumAge: 0 (default),												- пригодная информация из кеша, значение задается в секундах
					- timeout: Infinity (default)											- значение времени ожидания в секундах
				}
	- Управление историей посещений -
		1 способ
			Простейший способ работы с историей посещений связан связан с использованием location.hash и события haschange объекта window. Значения необходимо сохранять в location.hash который является url. В целом мутная система и устаревшая.
		2 способ
			- history.pushState()															- добавление состояния в историю. arg1- объект который содержит всю информацию, необходимую для восстановления текущего состояния. Подходит любой объект, который можно преобразовать с помощью JSON.stringify() и также Date и RegExp. При передаче производится полная (рекурсивная) копия объекта. arg2- необязательное заглавие, которую браузер сможет использовать для идентификации. arg3- передается необязательная строка url, которая будет отображаться как адрес текущего состояния.
			- popstate																			- событие при нажатии forward и back кнопок браузера. В объект event имеется переданный объект состояния
	- взаимодействие документов с разным происхождением -


	- фоновые потоки выполнения -
		выполняются асинхронно относительно основного потока и не имеют доступа к window и document. Сам фоновый поток выполняется синхронно и если в нем нет обработчика onmessage, то при всего сценария (в том числе таймеров и загрузок), поток завершается. Возможно обращаться к потоку через worker.postMessage(). Поток не может производить манипулированием элементов DOM и многие функции window и прочее.
		- объект worker -
			- var loader = new Worker('script.js')										- создает новый фоновый поток в переменную loader. в качестве аргумента можно передавать относительный и абсолютные пути. Если путь абсолютный, то он должен соответствовать политике общего происхождения.
			- loader.postMessage('file.txt'){...}										- отправить данные фоновому потоку. Можно передать текст и объект который будет преобразован в 'структурированную копию'.
			- workeer.onmessage(e){...}													- обработка события ответа от фонового потока
			- worker.terminate()																- остановить выполнение фонового потока
			Среда выполнения яаляется объектом WorkerGlobalScope, на который ссылаются this и self, который имеет следующие методы и к методам можно обращатся вообще без ссылки this|self:
				- postMessage()																- отправка ответа из фонового потока
				- onmessage = func(){...}													- обработка события сообщения фоновому потоку
				- close()																		- закрытие фонового потока (из фонового потока)
				- importScripts('script1.js', 'script2.js')							- синхронная загрузка библииотек и других сценариев в фоновом потоке, в порядке очереди объявления. Если есть ошибка в каком либо скрипте, дальнейшая загрузка прерывается. Сценарий загруженный с помощью importScripts может вызвывать importScripts, при этом нет защиты от циклических ссылок
			Помимо JSON, isNaN и конструктора Date(), WorkerGlobalScope имеет следующие методы и свойства:
				- self																			- ссылка на сам объект WorkerGlobalScope
				- методы работы с таймерами (setTimeout, clearInterval)
				- locarion																		- свойство, содержит url переданный конструктору Worker(). location имеет свойтсва: href, protocol, host, hostname, port, pathname, search, hash. В отличии от window, в потоке доступны только для чтения.
				- navigator																		- свойство с теми же свойствами, что и window. navigator фонового потока имеет свойства appName, appVersion, platform, userAgent и onLine
				- стандартные обработчики событий (но это не точно :) )
				- onerror																		- обработчик ошибок (на 2012, несовместим)
				- события и методы XMLHttpRequest
	- Типизированные массивы и буферы -
		имеется 8 типов типизированных массивов, которые саздаются с помоощью конструкторов в которых задается фиксированный разммер, все являются массивоподобными объектами:
			- Int8Array()																		- бай­ты со зна­ком
			- Uint8Array()																		- бай­ты без зна­ка
			- Int16Array()																		- 16-би­тные ко­рот­кие це­лые со зна­ком
			- Uint16Array()																	- 16-би­тные ко­рот­кие це­лые без зна­ка
			- Int32Array()																		- 32-би­тные це­лые со зна­ком
			- Uint32Array()																	- 32-би­тные це­лые без зна­ка
			- Float32Array()																	- 32-би­тные ве­ще­ст­вен­ные зна­че­ния
			- Float64Array()																	- 64-би­тные ве­ще­ст­вен­ные зна­че­ния
			пример: var arr = new Int8Array(24), можно инициализировать с помощью new Int8Array([1, 2, 3]);
			- int8arr.set([1, 2, 3], pos)													- скопировать элементы arg1 в начало int8arr, если установлен arg2- то с позиции указаной в arg2
			- var subarr = arr.subarray(arr.length - 3, arr.length)				- возратит чать массива. При этом возращенная часть все еще ссылается на основной массив
			Массив и подмассив ссылаются на одну область памяти, которая является буфером (объект ArrayBufer) -> subarr.bufer == arr вернет true. Буфер имеет 3 основных свйоства:
				- subarr.byteOffset															- вернет номер байта в буфере с которого начинается подмассив
				- subarr.byteLength															- вернет размер в байтах подмассива
				- subarr.buffer.byteLength													- вернет размер целого буфера в байтах
				- var buf = new ArrayBuffer(1024*1024)									- создать буфер на 1 мегабайт
				- var asints = new Int32array(buf)										- передать буфер конструктору
			В зависимости от платформы буфер может сохранятся в разных последовательнастях байтов (прямая и обратная), для проверки		new Int8Array(new Int32Array([1]).buffer)[0] === 1
			Для работы с внешними данными можно использовать Int8Array и Uint8Array, но есть удобный класс DataView, который определяет методы для чтения записи из буфера и указывает явно порядок (последовательность байтов), который имеет 8 методов записи и 8 чтения: setInt8, setFloat32, getInt8 и т.п.
				- var view = new DataView(data)											- создать представление буфера, где arg1- буфер ArrayBuffer
				- var int = view.getInt32(4)												- получить второе значение из буфера с прямой последовательностью, arg1- 4 байт(2 значение), arg2- false или отсутствие означает что прямая последовательность. true- обратная последовательность (не распространяется на int8).
				- view.setInt32(8, int, true)												- записать значение переменной int в третье значение буфера с обратной последовательностью.
	- Двоичные объекты -
		Представленны объектами blob (binary large object). Непрозрачны- все что мможно сделать, это получить размер и MIME-тип. Прикладные интерфейсы работают асинхронно, но есть и синхронные версии.
		- var blob = ...																		- получение объекта blob
		- blob.size																				- размер двоичного объекта
		- blob.tupe																				- MIME-type двоичного объекта
		- var subblob = blob.slice(0, 1024, 'text-plain')							- первый килобайт как текст
		- var last = blob.slice(blob.size - 1024, 1024)								- последний килобайт как нетипизированные данные
		получение объекта blob:
			- двоичные данные можно получить из другого окна или фонового потока
			- можно получить из баз данных на стороне клиента
			- получить из сети по hhtp XHR2
			- сконструировать с помощью ообъекта BlobBuilder и объекта ArrayBuffer
			- объект File является подтипом Blob. file имеет имя и даату последнего изменения и его можно получить через input[type=file], drug-and-drop, прикладной интерфейс доступа к файловой системе.
		с объектом blob можно производить следующие операции:
			- отправить окну или фоновому потоку методом postMessage()
			- сохранить в БД на стороне клиента
			- зашрузить на сервер с помощью XHR
			- мож­но вос­поль­зо­вать­ся createObjectURL(), что­бы по­лу­чить URL-ад­рес ви­да blob://, ссы­лаю­щий­ся на дво­ич­ное со­дер­жи­мое, и за­тем ис­поль­зо­вать его вме­сте с ме­ха­низ­ма­ми DOM или CSS
			- воспользоваться объектом fileReader, чтобы асинхронно (синхронно) извлечь содержимое двоичного объекта в строку или в ArrayBuffer
			- воспользоваться прикладным интерфейсом фаловой системы и объектом FileWriter что-бы записать двоичный объект в локальный файл
		- файлы как лвоичные объекты -
			file является подтипом blob и имеет дополнительно 2 свойства, помимо size и type:
				- file.lastModifiedDate														- дата последней модификации
				- file.name																		- имя файла
			производители браузеров не дадут присвоить сценарию значение в value во время выбора файла. присвоение происходит только после явного выбора пользователем файлов. В браузерах файлы после выбора сохраняются в массивоподобный объект FileList.
		- загрузка двоичных объектов -
			на момент написания книги браузеры не поддерживали
			function getBlob(url, callback){
				var xhr = new XMLHttpRequest();
				xhr.open('GET', url);
				xhr.onload = function(){ callback( xhr.response ); }			// Если файл слишком велик, можно повесить на событие onprogress
				xhr.send(null);
			}
		- конструирование двоичных объектов -
			BlobBuilder																		- устарел и не поддерживается
		- url- адреса, ссылающиеся на двоичные объекты -
			так как createObjectURL() не кроссбраузерна то для создания функции лучше применить
			- var getBlobURL = (window.URL && URL.createObjectURL.bind(URL)) ||  (window.webkitURL && webkitURL.createObjectURL.bind(webkitURL)) || window.createObjectURL;
			- createObjectURL()															- при передаче функции двоичного объекта вернет url 'blob://' за которым следует некоторая строка уникальный идентификатор. Идентификатор не является постоянным. При верезагрузке окна id изменится
			- URL.revokeObjectURL()														- прекращает действие URL-аддреса, давая возможность сборщику мусора удалить освободившееся пространство
			url-адрес созданный createObjectURL имеет происхождение такое жа как и сценарий, что дает некоторые преимущества
		- чтение двоичных объектов -
			Для чтения можно использовать объект FileReader, которому больше бы подошло название BloodReader. Действует асинхронно. Есть FileReaderSync- синхронный. Для работы необходимо создать объект fileReader с помощью конструктора. У него похожии события: load, error, progress как у XHR. После создания объекта fileReader и регистрации обработчиков, бинарный объект передается одному из четырех методов:
				- readAsText()																- arg1- объект blood, arg2- необязательный, определяет имя кодировки текста (default- utf-8). переводит двоичный файл (текст) в текст
				- readAsArrayBuffer()													- arg1- объект blood. Заносит значение в буфер ArrayBuffer
				- readAsDataURL()															- arg1- объект blood (не описывается в книге)
				- readAsBinaryString()													- arg1- объект blood (не описывается в книге)
			После создания объекта файлРидера обычно создаются обработчики событий и вызывается одна из функций. Результат получает в обработчике onload с помощью reader.result
	- прикладной интерфейс к файловой системе -
		для работы с файлами в файловой системе необходимо получить объект файловой системы синхронно или асинхронно
		- var fs = requestFileSystemSync(PERSISTENT, 1024 * 1024);			- синхронное получение объекта файловой системы, размером 1 МБ. PERSISTENT- возможно срок существования
		- requestFileSystem(TEMPORARY, 50*1024*1024,								- работа с объектом в асинхронном режиме, TEMPORARY- срок существования, 50 МБ
										function(fs){ код... },								функция в случае удачи
										funciton(e){ console.log(e); });					в случае ошибки
		- PERSISTENT																		- постоянный срок службы переменной
		- TEMPORARY																			- временный срок службы переменной (подходит для приложений которые кэшируют данные, но сохраняют работоспособность и после удаления объекта файловой системы)
		Размер указывается в разумных пределах, в зависимости от данных, которые необходимо будет сохранить. Браузер может ограничивать этот размер. Доступность файловой системы определяется политикой общего происхождения. Файловая система веб-приложения не имеет возможности получить доступ за пределы локального корневого каталога или иначе получить доступ к произвольным файлам. Когда приложение запрашивает доступ первый раз, браузер может спросить разрешение у пользователя и затем предоставлять доступ без вопросов.
		- fs.root																			- свойство, ссылается на корневой каталог файловой системы веб-приложения, который является объектом DirectoryEntry, который может содержать другие директории DirectoryEntry. В директории могут находится файлы, которые являются объектами FileEntry.
		- объект DirectoryEntry.createReader()										- определяет фабричный метод, возращающий объект DirectoryReader, который позволяет получить список содержимого каталога.
		- класс FileEntry.File															- метод для получения объекта File, который можно прочитать с помощью FileReader, есть еще метод получения fileWriter
		Работать с файловой системой намного проще, если выполнять синхронные функции(они кароче) в фоновых потоках
	- базы данных на стороне клиента -
		есть 2 вида баз данных на стороне клиента: 'Web SQL DataBase' и IndexedDB. IndexedDB это объектная, а не реляционная БД. Доступность определяется политикой общего происхождения. Каждая БД должна иметь уникальное имя. Хранилище хранит объекты. Объекты должны иметь уникальный ключ. Помимо извлечения из БД данных по ключю, есть возможность определить дополнительно любое количество индексов. Для получения всех обхектов по одному, используется курсор. Курсоры могут использоваться для получения диапазона в индексе. IndexedDB гарантирует атамарность операций (транзакции). Создание транзакции, поиск хранилища объектов и индексов являются синхронные операции. Открытие БД, обновление хранилища с помощтю put(), получение с помощью get() или openCursor()- асинхронные. В случае удачного запроса формируется событие success или error в случ. неудачи. С помощью abort() объекта транзакции можно отменить транзакцию и методы put(), get(). В IndexedDB транзакция подтверждается после выхода из обработчика success. Каждая БД содержит хранилище(а) объектов. Создавать хранилища объектов можно только внутри события success, возращаемую методом setVersion(). setVersion- позволяет устанавливать номер версии БД и неявно запускает транзакцию позволяющую запускать метод createObjectStore() и метод createIndex()
		- var indexedDB = window.indexedDB											- возращает объект предоставляющий API indexedDB
		- window.IDBTransaction															- возращает объект для работы с транзакциями
		- window.IDBRange																	- возращает объект для работы с диапазонвами индексов
		- var request = indexedDB.open('dbname')									- открыть БД dbname
		в общем ну его на )
	- веб-сокеты -
		- var socket = new WebSocket("ws://ws.example.com:1234/resource");
																								- создание сокета с помощью конструкторв, где ws-веб сокет или wss- безопасный веб-сокет (по аналогии с https), далее url-имя хоста, номер порта и путь либо ресурс.
		- socket.onopen = function(){...}											- обработчик события 'соединение установлено'
		- socket.onclose = function(){...}											- обработчик 'соединение закрыто'
		- socket.onerror = ...															- обработчик события ошибки соединения
		- socket.onmessage = ...														- обработчик события входящего сообщения
		- socket.send('message')														- передать серверу сообщение, на момент написания книги можно передаваать только строки
		- socket.close()																	- закрыть соединение