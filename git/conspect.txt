1 Начало работы с Git
	Управление версиями делятся на: локальные, централизованные, распределенные (гит)
	Файлы GIT могут находится в 3 основных состояниях: модифицированном, индексированном, зафиксированном.
		Зафиксированные файлы- сохранены в локальную бызу.
		Модифицированные файлы- файлы которые изменены, но пока не зафиксированы в БД
		Индексированное файлы- помеченные файлы на фиксацию в БД
	Git-проект в итоге имеет структуру: Рабочая папка (папка которая содержит одну из версий проекта git), Папка Git (в ней содержится БД и метаданные), область индексирования (файл который обычно находится в папке Git. Содержит информацию что войдет в следующую операцию фиксирования)
		- which git																			- место где установлен гит
		- git version																		- проверка версии git
	Создание конфигураций
		- git config --global user.name "First_name Last_name"				- при глобальном ключе, все проекты котрые будут создаваться на данном компьютере и под данной учетной записью будут иметь данную конфигурацию. Конфигурирование создается 1 раз.
			- --system																		- при данном флаге создастся системное конфигурирование (вроде для всех пользователей)
		- git config --global user.email "email"									- указать мыло
			без флага --global, производится локальное конфигурирование, которое нужно производить находясь в корневой директории git-проекта
			вся информация о конфигурации хранится в файле config. Все изменеия лучше производить с помощью команд
		- git config --global core.editor emacs									- утсановить текстовый редактор по умолчанию для работы с git (будет открываться при git commit)
		- git config --gloval color.ui true											- включить цветную (не монохромную подсветку) в git
		- git config --list																- вывод значений конфигурации
		- git config <key>																- вывести значение конкретного ключа в конфиге
		Все значения глобальной конфигурации (--global) сохраняются в файле .gitсonfig папки юзера (cd ~)
	Получение справочной информации
		1) git help <command>
		2) git <command> --help
		3) man git-<command>
		4) git help

2 Основы GIT
	Для создания проекта Git есть 2 пути: 1) Можно взять существующий проект или папку и импортировать в Git. 2) клонировать существующий репозиторий из другого проекта
	
	- git init																				- в указанной директории инициализирует git, создавая проект git
	- git clone [http || https и др. протоколы]
	
	- git add <file.txt || *.c>														- индексирует(начинает отслеживать файл, если он не ослеживаемый и добавляет как кандидат на фиксацию). Можно применить к файлу по имени, ко всем файлам в данной директории- '.', ко всем файлам (не только в данной директории- '*' но это не точно). Так-же помечает файлы с конфдиктом как разрешенные.
	- git add LICENSE																		-
	
	- git commit																			- откроет текстовый редактор указанный в конфигурации для описания комита и при закрытии редоактора, еси он не пуст фиксируются файлы (создается комит)
		-v																						- с этим флагом в редактор будут добавленны иземенения в файлах
	- git commit -m "Enter your commit"												- ввести текстовый коментарий изменения "commit"
	- git commit -a																		- автоматически проиндексирует все отслеживаемые файлы и зафиксирует их. Пример git commit -m "message" -a
	Каждый файл может пребывать в 2 состояних: отслеживаемый и неотслеживаемый. Отслеживаемые- это неизмененные, измененные и подготовленные к фиксации. Не отслеживаемые- все остальные.
	Заголовок коммита должен содержать до 50 символов, а дальнейшие строки до 72 символов.
	
	- git status																			- вывод состояния рабочего каталога. Можно применить флаг -s и --short. При короткой записи статуса у фалов будут присутствовать префиксы '??', 'A', 'M'. ??- новый непроиндексированный файл. А- новый проиндексированный, но не зафиксированный D- удаленный но не проиндксированный, M green/red- модифицированный проиндексированный/непроиндексированный
	
	игнорирование файлов
	для игнрирования отслеживания файлов обычно используется файл .gitignore с содержанием типа $ cat .gitignore *.[oa] или *~ (не отслеживать фалы кончающиеся на '.a' или '.o', все файлы заканчивающиеся на ~)	исчерпывающий список на https://github.com/github/gitignore. Используемые комбинации напоминают упрощенные регулярные выражения
	
	- git diff																				- показывает измененные строки в НЕиндексированных файлах.
		-- cached																			- покажет изменения индексированного файла
		-- staged																			- тоже-самое что и cached
		-- color-words																		- вывод отличий на одной строке
	- git diff <sha1>																		- покажет все изменения между рабочей директорией в данный момент и рабочими данными в данном коммите
	- git diff <sha1> <file>															- тоже самое, но для конкретного файла
	- git diff <sha1>..<sha1>															- разница между состояниями двух коммитов
	- git diff <sha1>..<sha1> <file>													- тоже самое но для одного файла
	- git diff --stat --summary <sha1>..HEAD										- покажет кратко все изменения в табличке от данного комита до HEAD
		-b																						- игнорирует добавление и удаление пробелов
		-w																						- игнорирует любые изменения с пробелами	
	
	- git rm 'file'																		- удаляет из области индексирования и из директории отслеживаемый но неиндексированный файл. Можно передавать файлы, папки и глобальные паттерны (прим. git/rm/\*.log обоатный слешь необходим т.к. гит добавляет его перед именами файлов как я понял)
		-f																						- использовать этот флаг для принудительного удаления (если файл проиндексирован)
	- git rm --cached README															- оставит файлы в папке, но удалит из индексирования (как я понял вообще слежение гитом, но это не точно).
	- git rm --cached . -f -r															- удалить все из индексирования
	
	- git mv file1.txt file2.txt														- git поймет как переименование. Эквивалентно ~/mv, git rm, git add;
	
	- git log																				- получить список истории (логов)
		- git log -p																		- показывает разницу внесенную каждым коммитом
		- git log -p -2																	- пред. + вывести 2 последних коммита
		- git log --stat																	- вывод истории в которой кратко описывается изменение каждого файла (количество измененных строк)
		- git log --pretty=oneline														- вывести список коммитов по одной строке
		- git log --pretty=oneline --max-count=3									- вывести из истории последние 3 значения по одной строке
		- git log --pretty=oneline --all												- вывести все значения истории (так как обычный git log может выводить не все)
		- git log --pretty=oneline --author="first_name last_name"			- вывести коммиты по автору
		- git log --pretty=format:"%h - %s : %ad [%an]"							- вывод в фомате, где %h- короткая версия хэша, %s- название коммита, %ad- дата, %an- автор
		- git log --pretty=format:"%h - %s : %ad [%an] %d" --date="short"	- --data="short", форматирует дату в короткую форму. %d- выводит в конце первой строки название ветки
			--graph																			- флаг который добавляет историю ветвлений (целесообразен с флагом --all)
		- git log --since (--after)													- ограничить коммиты после указанной даты. Прим. git log --since=2.weeks (покажет последние 2 недели)
		- git log --until (--before)													- ограничить до указанной даты
		- git log 
			- могут работать с разными форматами данных '2018-01-15'
		- git log --author																- определить версии указанные автором. Можно указывать часть имени
			-- grep																			- позволяет искать ключевые слова (вроде и регулярные выражения могет)
				--all-match																	- для использования всех указанных критериев поиска (grep author), если не указать, то выведутся все результаты, которые удовлетворяют любому условию поиска
			--s																				- указав строку этому параметру, будут выведены все логи в которые добавлялась или удалялась данная строка
			-- folder/																		- указывается в конце для поиска в указанном пути
			--no-merges																		- пропустить слияния
		- git log --decorate																- позволяет узнать где находятся указатели веток и указатель HEAD

	- git commit --amend																	- добавляет в последний коммит новые индексированные файлы

	Удаленые репазитории (могут использоваться разными протоколами передачи данных)
	
	- git clone [http || https]														- скопировать проект git из удаленного репозитория
	- git clone -o <name>																- скопировать проект и получить название сервера (по умолчанию origin)

	- git remote																			- возращает список коротких имен для всех областей удаленной работы
		-v																						- выводит url для сокращенных имен при чтении(fetch) и при записи(push)
	- git remote add <сокращенной имя> <url>										- создать сокращенное имя для работы с url
	- git remote fetch <сокращенное имя>											- получить всю информацию с удаленного репозитория. сообщение master->pb/master говорит о том что информация доступна как pb/master, которую можно использовать для слияния или просто проверить ее содержимое
	- git remote show <url (сокр url)>												- вывод дополнительной информации об удаленном репозитории (выводит информацию о ветах и о готовности команд pull, push)
	- git remote rename pb paul														- переименование сокращенного удаленного репозитория
	- git remote rm pb																	- удалить сокращенное имя удаленного репозитория

	Тэги бывают простыми(легковесными (указатель на конкретный комит)), и тэг с коментарием- который хранится как полноценный объект. Они обладают контрольной суммой, содержат имя человека, поставившего тег, адрес почты и дату создания. Тэги не передаются на сервер во время выгрузки с помощью git push, по этому их необходимо отправлятть отдельно
	- git tag																				- выводит список всех тегов в алфавитном порядке
	- git tag -a <name of new tag> -m 'comment for tag'						- добавить новый тэг с комментарием (добавляется последнему коммиту)
	- git tag <name of new tag>														- новый легковесный тэг (добавляется последнему коммиту)
	- git show v1.4																		- вывести коммит с тэгом v1.4
	- git show <sha1>																		- показывает подробную информацию о коммите
		вместо <sha1> можно передавать HEAD~ или HEAD^, что значит вернуть предка HEAD. Так же модно писать HEAD^^ или HEAD~2
	- git push origin v1.4																- отправить на удаленный репазиторий origin тэг v1.4 (один тэг)
	- git push origin --tags															- отправить все тэги на удаленный репозиторий

	создание алиаса (псевдонима)
	- git config --global alias.st status											- создание алиаса. теперь вместо git status достаточно ввести git st
	- git config --global --unset alias.trololo									- удалить алиас trololo
	- git config --global alias.gk "!gitk"											- запустить внешнюю команду gitk, как git gk

3 Ветвления git
	- git branch																			- выведет все ветки и здездой укажет где в данный момент находится HEAD
		- -v																					- выведет все ветки со звездой и дополнительно хэш и название коммита последних коммитов веток
		- --merge																			- выведет активную ветку и ветки которые были слиту в эту ветку
		- --no-merge																		- выведет только те ветки, которые не влились в данную ветку
	- git branch <nameBranc>															- создает новую ветку, но не переводит указатель HEAD
		- -d																					- удаляет ветку, если она влита в другую
		- -D																					- удаляет ветку даже если она никуда не влилась
	
	- git checkout <nameBranch>														- перейти на ветку (перевести ук-ль HEAD). Если есть неизмененные и незафиксированные файлы, переход невозможен
		- -b																					- создать ветку и перейти
		- -vv																					- вывести список веток и за какими удаленными ветками наблюжают данные ветки (данные берутся из кэша. по этому лучше заранее применить git fetch --all). Также комнда показывает сколько есть локальных коммитов которых нет на удаленном реп. (behind n) и наоборот (ahead n)- где n- количество
		- -u <origin/branch>																- указать данной ветке за какой веткой следить
		- -b <nameBranch> <origin>/<serverNameBranch>							- создать копию серверной ветки у себя локально (при этом ветка будет отслеживать изменения. Из этой ветки можно отправлять git push, git pull без параметров)
		- --track origin/branch															- как пред. но нельзя переименовать локальную ветку
	- git checkout -- <file>															- вернуться к прежней версии файла (к той, котроая зафиксирована). При этом все изменения будут утеряны, т.к. они нигде не сохранены. В случае присутствия одноименной ветки с фалом, хорошей практикой является применение --, которая указывает именно файл

	- @{u}																					- или @{upstream}. короткое обращение к удаленной ветке, если она является отслеживаемой. git merge @{u}

	У слияния есть три варианта:
		- Слияние коммита предка с новой веткой (быстрое слияние). В этом случае нужно перейти на ветку с комитом предком и из него производить слияние. При этом просто произойдет перенос указателя ветки
		- От ветвленного коммита (ветки), которая не является предком для второй ветки (объединение без конфликта). Создастся промежуточнный (merge) commit. А файлы объеденятся из 2 веток
		- От ветвленного коммита (ветки), которая не является предком для второй ветки и у которых есть хотябы один общий файл с разным содержанием (конфликт). Есть 3 пути решения:
			- отменить слияние
			- решить конфлик вручную (открыть файлы которые конфликтный- git status подскажет какие, и исправить)
			- воспользоваться margetool
	- git merge <nameBranch>															- слияние веток. Параметром указывается ветка, которую необходимо поглотить
		- --abort																			- отмена слияния
	
	- git fetch <origin>																	- обновить локальную базу. Сдвигаются указатели веток (типа origin/master) на новую актуальную позицию
		- --all																				- получить обновление со всех внешних репозиториев

	- git pull 																				- извлекает данные из удаленного репозитория и автоматически пытается слить с локальной веткой
	- git pull --rebase <origin> <master>											- объединит серверную ветку (если ей делали rebase) и затем произойдет перемещение в ветку мастер. Но отличающиеся коммиты мастера пойдут в конец

	- git push <origin (сокр url)> <branch>										- отправка данных(ветки) на сервер. Альтернативные варианты далее в гл. 3
	- git push <origin>  <nameBranch1> : <nameBranch2>							- отправить свою ветку nameBranch1 и сохранить ее на сервере как nameBranch2
	- git push <origin> --delete <branch>											- удалить ветку с удаленного репозитория

	- git rebase <master>																- перемещние ветки в указанную ветку. Все коммиты данной будут вставленны за указатель master при этом будут произведены сравнения с общим предком (эта разница и будет добавлена в новые коммиты). После этого ветки еще не объеденены. Можно произвести быстрое слияние и удаление старой ветки
	- git rebase <branch1> <branch2>													- тоже самое, но производит переход на branch2 и производит перемещение в branch1
	- git revase --onto <master> <server> <client> 								- (ситуация при которой есть ветка master от которой ответвляется server, а от server- client) Позволяет переместить ветку client до общего предка с server в ветку master
	! Важно после добавления ветки на сервер не переносить ее, так как это может вызвать много путаниц

	- git config --global credential.helper cache								- для того что-бы не вводить пароль каждый раз, настраивает кэш (вроде только с https и на несколько минут)
	При переходе в локальную ветку созданной из удаленной, автоматически создается "ветка наблюдения". Набрав в этой ветке git push или git pull без аргументов, гит поймет с какой веткой нужно работать.

	- git revert <sha1>																	- отменяет все действия коммита <sha1> и создает новый коммит для пояснения

	- git reset <file>																	- удалить файл из кондидата в коммит
	- git reset --soft <sha1>															- перемещает указатель HEAD без изменения рабочей папки, изменения автоматически добавляется в буфер
		--mixed (default) <sha1>														- перемещает указатель, но буфер пустой
	- git reset --hard																	- перемещает указатель, удаляя все изменеия в рабочем проекте. Буфер остается пустой

	- git clean -n																			- покажет какие файлы могут быть удалены (которые есть в проекте но не включены не в буфер не в коммиты)
	- git clean -f																			- удалит

	--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

	- git ls-tree HEAD																	- покажет все файлы на момент донного коммита списком (игнорируемые файлы не попадут) где tree- папки, blob- файлы. Если скопировать ls-treesh (sha1)-папки, то в правой части таблицы список фалов и папок будет без префиксов (папки sha1-которой мы передавали)